<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>用 JavaScript 写一个简单的编译器【译】 · Go7hic</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="注：本文来自 https://github.com/thejameskyle/the-super-tiny-compiler "/><meta name="docsearch:language" content="en"/><meta property="og:title" content="用 JavaScript 写一个简单的编译器【译】 · Go7hic"/><meta property="og:type" content="website"/><meta property="og:url" content="https://yongyuan.us/blog/2017/10/08/js-compiler"/><meta property="og:description" content="注：本文来自 https://github.com/thejameskyle/the-super-tiny-compiler "/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/tx.jpeg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://yongyuan.us/blog/atom.xml" title="Go7hic Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://yongyuan.us/blog/feed.xml" title="Go7hic Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/tx.jpeg" alt="Go7hic"/><h2 class="headerTitleWithLogo">Go7hic</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/blog/" target="_self">blog</a></li><li class=""><a href="/docs/technology/doc1" target="_self">docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2018/03/10/web-sec-check-list">Web Developer Security Checklist【译】</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/blog/2017/10/08/js-compiler">用 JavaScript 写一个简单的编译器【译】</a></li><li class="navListItem"><a class="navItem" href="/blog/2017/04/10/react-fiber">React Fiber 架构【译】</a></li><li class="navListItem"><a class="navItem" href="/blog/2016/09/17/ios-dev-3">写给前端的 iOS 开发教程(3)：iOS 与 ReactNative 混合开发</a></li><li class="navListItem"><a class="navItem" href="/blog/2016/09/17/ios-dev-2">写给前端的 iOS 开发教程(2)：熟悉 CocoaPods</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2017/10/08/js-compiler">用 JavaScript 写一个简单的编译器【译】</a></h1><p class="post-meta">October 8, 2017</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><div><span><p>注：本文来自 <a href="https://github.com/thejameskyle/the-super-tiny-compiler">https://github.com/thejameskyle/the-super-tiny-compiler</a></p>
<blockquote>
<p>这是一个超级简单的编译器的例子，包含了现代编译器的几个主要部分，用简单易读的 JavaScript 编写。</p>
</blockquote>
<p>把这个读完将会有助于你了解大多数编译器从前端到后端是如何工作的。</p>
<p>今天让我们来写一个编译器，一个超级无敌小的编译器！它小到如果把所有注释删去的话，大概只剩 200行左右的代码。 我们将会用它将 lisp 风格的函数调用转换为 C 风格。 如果你对这两种风格不是很熟悉，下面是一个简单的介绍。 假设我们有两个函数，<code>add</code> 和 <code>subtract</code>，那么它们的写法将会是下面这样：</p>
<pre><code class="hljs">                   LISP                      C
 
    <span class="hljs-number">2</span> + <span class="hljs-number">2</span>          (add <span class="hljs-number">2</span> <span class="hljs-number">2</span>)                 add(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
    <span class="hljs-number">4</span> - <span class="hljs-number">2</span>          (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>)            subtract(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)
    <span class="hljs-number">2</span> + (<span class="hljs-number">4</span> - <span class="hljs-number">2</span>)    (add <span class="hljs-number">2</span> (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>))    add(<span class="hljs-number">2</span>, subtract(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>))
 
</code></pre>
<p>很简单对吧？</p>
<p>这个转换就是我们将要做的事情。虽然这并不包含 LISP 或者 C 的全部语法，但它足以向我们展示现代编译器很多要点。</p>
<p>大多数编译器可以分成三个阶段：解析（Parsing），转换（Transformation）以及代码生成（Code Generation）</p>
<ul>
<li><ol>
<li><em>解析</em>是将最初原始的代码转换为一种更加抽象的表示（译者注：即AST）。*</li>
</ol></li>
<li><ol start="2">
<li><em>转换</em>将对这个抽象的表示做一些处理，让它能做到编译器期望它做到的事情。</li>
</ol></li>
<li><ol start="3">
<li><em>代码生成</em>接收处理之后的代码表示，然后把它转换成新的代码。</li>
</ol></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="解析-parsing"></a><a href="#解析-parsing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解析 Parsing</h3>
<p>解析一般来说会分成两个阶段：词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）。</p>
<ol>
<li><p><em>词法分析</em>接收原始代码，然后把它分割成一些被称为 Token 的东西，这个过程是在词法分析器（Tokenizer或者Lexer）中完成的。</p>
<p>Token 是一个数组，由一些代码语句的碎片组成。它们可以是数字、标签、标点符号、运算符，
或者其它任何东西。</p></li>
<li><p><em>语法分析</em> 接收之前生成的 Token，把它们转换成一种抽象的表示，这种抽象的表示描述了代
码语句中的每一个片段以及它们之间的关系。这被称为中间表示（intermediate representation）
或抽象语法树（Abstract Syntax Tree， 缩写为AST）</p>
<p>抽象语法树是一个嵌套程度很深的对象，用一种更容易处理的方式代表了代码本身，也能给我们
更多信息。</p></li>
</ol>
<p>比如说对于下面这一行代码语句：</p>
<pre><code class="hljs"> (<span class="hljs-name">add</span> <span class="hljs-number">2</span> (<span class="hljs-name">subtract</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span>))
</code></pre>
<p>它产生的 Token 看起来或许是这样的：</p>
<pre><code class="hljs">   [
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">'('</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'name'</span>,   <span class="hljs-string">value:</span> <span class="hljs-string">'add'</span>      },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'number'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">'('</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'name'</span>,   <span class="hljs-string">value:</span> <span class="hljs-string">'subtract'</span> },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'number'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'number'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">')'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">')'</span>        }
   ]
</code></pre>
<p>它的抽象语法树（AST）看起来或许是这样的：</p>
<pre><code class="hljs">*
*   {
*     <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>,
*     <span class="hljs-string">body:</span> [{
*       <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
*       <span class="hljs-string">name:</span> <span class="hljs-string">'add'</span>,
*       <span class="hljs-string">params:</span> [{
*         <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
*         <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
*       }, {
*         <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
*         <span class="hljs-string">name:</span> <span class="hljs-string">'subtract'</span>,
*         <span class="hljs-string">params:</span> [{
*           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
*           <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>
*         }, {
*           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
*           <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
*         }]
*       }]
*     }]
*   }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="转换-transformation"></a><a href="#转换-transformation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换（Transformation）</h3>
<p>编译器的下一步就是转换。它只是把 AST 拿过来然后对它做一些修改。它可以在同种语言下操作 AST，也可以把 AST 翻译成全新的语言。</p>
<p>下面我们来看看该如何转换 AST。</p>
<p>你或许注意到了我们的 AST 中有很多相似的元素，这些元素都有 type 属性，它们被称为 AST 结点。这些结点含有若干属性，可以用于描述 AST 的部分信息。</p>
<p>比如下面是一个“NumberLiteral”结点：</p>
<pre><code class="hljs">{
    <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
    value: <span class="hljs-string">'2'</span>
}
</code></pre>
<p>又比如下面是一个“CallExpression”结点：</p>
<pre><code class="hljs">
 {
   <span class="hljs-attribute">type</span>: <span class="hljs-string">'CallExpression'</span>,
   name: <span class="hljs-string">'subtract'</span>,
   params: [...nested nodes go here...]
}

</code></pre>
<p>当转换 AST 的时候我们可以添加、移动、替代这些结点，也可以根据现有的 AST 生成一个全新的 AST</p>
<p>既然我们编译器的目标是把输入的代码转换为一种新的语言，所以我们将会着重于产生一个针对新语言的全新的 AST。</p>
<h3><a class="anchor" aria-hidden="true" id="遍历-traversal"></a><a href="#遍历-traversal" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>遍历（Traversal）</h3>
<p>为了能处理所有的结点，我们需要遍历它们，使用的是深度优先遍历。</p>
<pre><code class="hljs">  {
     <span class="hljs-attribute">type</span>: <span class="hljs-string">'Program'</span>,
     <span class="hljs-attribute">body</span>: [{
       <span class="hljs-attribute">type</span>: <span class="hljs-string">'CallExpression'</span>,
       <span class="hljs-attribute">name</span>: <span class="hljs-string">'add'</span>,
       <span class="hljs-attribute">params</span>: [{
         <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
         <span class="hljs-attribute">value</span>: <span class="hljs-string">'2'</span>
      }, {
         <span class="hljs-attribute">type</span>: <span class="hljs-string">'CallExpression'</span>,
         <span class="hljs-attribute">name</span>: <span class="hljs-string">'subtract'</span>,
         <span class="hljs-attribute">params</span>: [{
            <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
            <span class="hljs-attribute">value</span>: <span class="hljs-string">'4'</span>
          }, {
            <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
            <span class="hljs-attribute">value</span>: <span class="hljs-string">'2'</span>
          }]
        }]
      }]
   }
</code></pre>
<p>对于上面的 AST 的遍历流程是这样的：</p>
<ol>
<li>Program - 从 AST 的顶部结点开始</li>
<li>CallExpression (add) - Program 的第一个子元素</li>
<li>NumberLiteral (2) - CallExpression (add) 的第一个子元素</li>
<li>CallExpression (subtract) - CallExpression (add) 的第二个子元素</li>
<li>NumberLiteral (4) - CallExpression (subtract) 的第一个子元素</li>
<li>NumberLiteral (2) - CallExpression (subtract) 的第二个子元素</li>
</ol>
<p>如果我们直接在 AST 内部操作，而不是产生一个新的 AST，那么就要在这里介绍所有种类的抽象，</p>
<p>但是目前访问（visiting）所有结点的方法已经足够了。</p>
<p>使用“访问（visiting）”这个词的是因为这是一种模式，代表在对象结构内对元素进行操作。</p>
<h3><a class="anchor" aria-hidden="true" id="访问者-visitors"></a><a href="#访问者-visitors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问者（Visitors）</h3>
<p>我们最基础的想法是创建一个“访问者（visitor）”对象，这个对象中包含一些方法，可以接收不同的结点。</p>
<pre><code class="hljs"><span class="xml">   var visitor = </span><span class="hljs-template-variable">{
     NumberLiteral() {}</span><span class="xml">,
     CallExpression() </span><span class="hljs-template-variable">{}</span><span class="xml">
   };
</span></code></pre>
<p>当我们遍历 AST 的时候，如果遇到了匹配 type 的结点，我们可以调用 visitor 中的方法。</p>
<p>一般情况下为了让这些方法可用性更好，我们会把父结点也作为参数传入。</p>
<h3><a class="anchor" aria-hidden="true" id="代码生成-code-generation"></a><a href="#代码生成-code-generation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码生成（Code Generation）</h3>
<p>编译器的最后一个阶段是代码生成，这个阶段做的事情有时候会和转换（transformation）重叠，但是代码生成最主要的部分还是根据 AST 来输出代码。代码生成有几种不同的工作方式，有些编译器将会重用之前生成的 token，有些会创建独立的代码表示，以便于线性地输出代码。但是接下来我们还是着重于使用之前生成好的 AST。 我们的代码生成器需要知道如何“打印”AST 中所有类型的结点，然后它会递归地调用自身，直到所有代码都被打印到一个很长的字符串中。</p>
<p>好了！这就是编译器中所有的部分了。 当然不是说所有的编译器都像我说的这样。不同的编译器有不同的目的，所以也可能需要不同的步骤。 但你现在应该对编译器到底是个什么东西有个大概的认识了。
既然我全都解释一遍了，你应该能写一个属于自己的编译器了吧？哈哈开个玩笑，接下来才是重点 :P</p>
<p>所以我们开始吧...</p>
<h3><a class="anchor" aria-hidden="true" id="词法分析器-tokenizer"></a><a href="#词法分析器-tokenizer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>词法分析器（Tokenizer）!</h3>
<p>我们从第一个阶段开始，即词法分析，使用的是词法分析器（Tokenizer）。 我们只是接收代码组成的字符串，然后把它们分割成 token 组成的数组。</p>
<pre><code class="hljs">   (<span class="hljs-keyword">add</span><span class="bash"> 2 (subtract 4 2))   =&gt;   [{ <span class="hljs-built_in">type</span>: <span class="hljs-string">'paren'</span>, value: <span class="hljs-string">'('</span> }...]</span>
</code></pre>
<pre><code class="hljs">
<span class="hljs-comment">// 我们从接收一个字符串开始，首先设置两个变量。</span>
<span class="hljs-function">function <span class="hljs-title">tokenizer</span>(<span class="hljs-params">input</span>)</span> {

 <span class="hljs-comment">// `current`变量类似指针，用于记录我们在代码字符串中的位置。</span>
 <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;

 <span class="hljs-comment">// `tokens`数组是我们放置 token 的地方</span>
 <span class="hljs-keyword">var</span> tokens = [];

 <span class="hljs-comment">// 首先我们创建一个 `while` 循环， `current` 变量会在循环中自增。</span>
 <span class="hljs-comment">// </span>
 <span class="hljs-comment">// 我们这么做的原因是，由于 token 数组的长度是任意的，所以可能要在单个循环中多次</span>
 <span class="hljs-comment">// 增加 `current` </span>
 <span class="hljs-keyword">while</span> (current &lt; input.length) {

   <span class="hljs-comment">// 我们在这里储存了 `input` 中的当前字符</span>
   <span class="hljs-keyword">var</span> <span class="hljs-keyword">char</span> = input[current];

   <span class="hljs-comment">// 要做的第一件事情就是检查是不是右圆括号。这在之后将会用在 `CallExpressions` 中，</span>
   <span class="hljs-comment">// 但是现在我们关心的只是字符本身。</span>
   <span class="hljs-comment">//</span>
   <span class="hljs-comment">// 检查一下是不是一个左圆括号。</span>
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">char</span> === <span class="hljs-string">'('</span>) {

     <span class="hljs-comment">// 如果是，那么我们 push 一个 type 为 `paren`，value 为左圆括号的对象。</span>
     tokens.push({
       type: <span class="hljs-string">'paren'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-string">'('</span>
     });

     <span class="hljs-comment">// 自增 `current`</span>
     current++;

     <span class="hljs-comment">// 结束本次循环，进入下一次循环</span>
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 然后我们检查是不是一个右圆括号。这里做的时候和之前一样：检查右圆括号、加入新的 token、</span>
   <span class="hljs-comment">// 自增 `current`，然后进入下一次循环。</span>
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">char</span> === <span class="hljs-string">')'</span>) {
     tokens.push({
       type: <span class="hljs-string">'paren'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-string">')'</span>
     });
     current++;
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 继续，我们现在检查是不是空格。有趣的是，我们想要空格的本意是分隔字符，但这现在</span>
   <span class="hljs-comment">// 对于我们储存 token 来说不那么重要。我们暂且搁置它。</span>
   <span class="hljs-comment">// </span>
   <span class="hljs-comment">// 所以我们只是简单地检查是不是空格，如果是，那么我们直接进入下一个循环。</span>
   <span class="hljs-keyword">var</span> WHITESPACE = /\s/;
   <span class="hljs-keyword">if</span> (WHITESPACE.test(<span class="hljs-keyword">char</span>)) {
     current++;
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 下一个 token 的类型是数字。它和之前的 token 不同，因为数字可以由多个数字字符组成，</span>
   <span class="hljs-comment">// 但是我们只能把它们识别为一个 token。</span>
   <span class="hljs-comment">// </span>
   <span class="hljs-comment">//   (add 123 456)</span>
   <span class="hljs-comment">//        ^^^ ^^^</span>
   <span class="hljs-comment">//        Only two separate tokens</span>
   <span class="hljs-comment">//        这里只有两个 token</span>
   <span class="hljs-comment">//        </span>
   <span class="hljs-comment">// 当我们遇到一个数字字符时，将会从这里开始。</span>
   <span class="hljs-keyword">var</span> NUMBERS = /[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]/;
   <span class="hljs-keyword">if</span> (NUMBERS.test(<span class="hljs-keyword">char</span>)) {

     <span class="hljs-comment">// 创建一个 `value` 字符串，用于 push 字符。</span>
     <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">''</span>;

     <span class="hljs-comment">// 然后我们循环遍历接下来的字符，直到我们遇到的字符不再是数字字符为止，把遇到的每</span>
     <span class="hljs-comment">// 一个数字字符 push 进 `value` 中，然后自增 `current`。</span>
     <span class="hljs-keyword">while</span> (NUMBERS.test(<span class="hljs-keyword">char</span>)) {
       <span class="hljs-keyword">value</span> += <span class="hljs-keyword">char</span>;
       <span class="hljs-keyword">char</span> = input[++current];
     }

     <span class="hljs-comment">// 然后我们把类型为 `number` 的 token 放入 `tokens` 数组中。</span>
     tokens.push({
       type: <span class="hljs-string">'number'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-keyword">value</span>
     });

     <span class="hljs-comment">// 进入下一次循环。</span>
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 最后一种类型的 token 是 `name`。它由一系列的字母组成，这在我们的 lisp 语法中</span>
   <span class="hljs-comment">// 代表了函数。</span>
   <span class="hljs-comment">//</span>
   <span class="hljs-comment">//   (add 2 4)</span>
   <span class="hljs-comment">//    ^^^</span>
   <span class="hljs-comment">//    Name token</span>
   <span class="hljs-comment">//</span>
   <span class="hljs-keyword">var</span> LETTERS = /[a-z]/i;
   <span class="hljs-keyword">if</span> (LETTERS.test(<span class="hljs-keyword">char</span>)) {
     <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">''</span>;

     <span class="hljs-comment">// 同样，我们用一个循环遍历所有的字母，把它们存入 value 中。</span>
     <span class="hljs-keyword">while</span> (LETTERS.test(<span class="hljs-keyword">char</span>)) {
       <span class="hljs-keyword">value</span> += <span class="hljs-keyword">char</span>;
       <span class="hljs-keyword">char</span> = input[++current];
     }

     <span class="hljs-comment">// 然后添加一个类型为 `name` 的 token，然后进入下一次循环。</span>
     tokens.push({
       type: <span class="hljs-string">'name'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-keyword">value</span>
     });

     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 最后如果我们没有匹配上任何类型的 token，那么我们抛出一个错误。</span>
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(<span class="hljs-string">'I dont know what this character is: '</span> + <span class="hljs-keyword">char</span>);
 }

 <span class="hljs-comment">// 词法分析器的最后我们返回 tokens 数组。</span>
 <span class="hljs-keyword">return</span> tokens;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="语法分析器-parser"></a><a href="#语法分析器-parser" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>语法分析器（Parser）!!!</h3>
<p>语法分析器接受 token 数组，然后把它转化为 AST</p>
<pre><code class="hljs">  [{ <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'('</span> }, ...]   =&gt;   { <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>, <span class="hljs-string">body:</span> [...] }
</code></pre>
<pre><code class="hljs"><span class="hljs-regexp">//</span> 现在我们定义 parser 函数，接受 `tokens` 数组
<span class="hljs-keyword">function</span> parser(tokens) {

  <span class="hljs-regexp">//</span> 我们再次声明一个 `current` 变量作为指针。
  var current = <span class="hljs-number">0</span>;

  <span class="hljs-regexp">//</span> 但是这次我们使用递归而不是 `<span class="hljs-keyword">while</span>` 循环，所以我们定义一个 `walk` 函数。
  <span class="hljs-keyword">function</span> walk() {

    <span class="hljs-regexp">//</span> walk函数里，我们从当前token开始
    var token = tokens[current];

    <span class="hljs-regexp">//</span> 对于不同类型的结点，对应的处理方法也不同，我们从 `number` 类型的 token 开始。
    <span class="hljs-regexp">//</span> 检查是不是 `number` 类型
    <span class="hljs-keyword">if</span> (token.type === <span class="hljs-string">'number'</span>) {

      <span class="hljs-regexp">//</span> 如果是，`current` 自增。
      current++;

      <span class="hljs-regexp">//</span> 然后我们会返回一个新的 AST 结点 `NumberLiteral`，并且把它的值设为 token 的值。
      return {
        type: <span class="hljs-string">'NumberLiteral'</span>,
        value: token.value
      };
    }

    <span class="hljs-regexp">//</span> 接下来我们检查是不是 CallExpressions 类型，我们从左圆括号开始。
    <span class="hljs-keyword">if</span> (
      token.type === <span class="hljs-string">'paren'</span> &amp;&amp;
      token.value === <span class="hljs-string">'('</span>
    ) {

      <span class="hljs-regexp">//</span> 我们会自增 `current` 来跳过这个括号，因为括号在 AST 中是不重要的。
      token = tokens[++current];

      <span class="hljs-regexp">//</span> 我们创建一个类型为 `CallExpression` 的根节点，然后把它的 name 属性设置为当前
      <span class="hljs-regexp">//</span> token 的值，因为紧跟在左圆括号后面的 token 一定是调用的函数的名字。 
      var node = {
        type: <span class="hljs-string">'CallExpression'</span>,
        name: token.value,
        params: []
      };

      <span class="hljs-regexp">//</span> 我们再次自增 `current` 变量，跳过当前的 token 
      token = tokens[++current];

      <span class="hljs-regexp">//</span> 现在我们循环遍历接下来的每一个 token，直到我们遇到右圆括号，这些 token 将会
      <span class="hljs-regexp">//</span> 是 `CallExpression` 的 `params`（参数）
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 这也是递归开始的地方，我们采用递归的方式来解决问题，而不是去尝试解析一个可能有无限
      <span class="hljs-regexp">//</span> 层嵌套的结点。
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 为了更好地解释，我们来看看我们的 Lisp 代码。你会注意到 `add` 函数的参数有两个，
      <span class="hljs-regexp">//</span> 一个是数字，另一个是一个嵌套的 `CallExpression`，这个 `CallExpression` 中
      <span class="hljs-regexp">//</span> 包含了它自己的参数（两个数字）
      <span class="hljs-regexp">//</span>
      <span class="hljs-regexp">//</span>   (add <span class="hljs-number">2</span> (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>))
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 你也会注意到我们的 token 数组中有多个右圆括号。
      <span class="hljs-regexp">//</span>
      <span class="hljs-regexp">//</span>   [
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">'('</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'name'</span>,   value: <span class="hljs-string">'add'</span>      },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'number'</span>, value: <span class="hljs-string">'2'</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">'('</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'name'</span>,   value: <span class="hljs-string">'subtract'</span> },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'number'</span>, value: <span class="hljs-string">'4'</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'number'</span>, value: <span class="hljs-string">'2'</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">')'</span>        }, &lt;&lt;&lt; 右圆括号
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">')'</span>        }  &lt;&lt;&lt; 右圆括号
      <span class="hljs-regexp">//</span>   ]
      <span class="hljs-regexp">//</span>
      <span class="hljs-regexp">//</span> 遇到嵌套的 `CallExpressions` 时，我们将会依赖嵌套的 `walk` 函数来
      <span class="hljs-regexp">//</span> 增加 `current` 变量
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 所以我们创建一个 `<span class="hljs-keyword">while</span>` 循环，直到遇到类型为 `<span class="hljs-string">'paren'</span>`，值为右圆括号的 token。 
      <span class="hljs-keyword">while</span> (
        (token.type !== <span class="hljs-string">'paren'</span>) ||
        (token.type === <span class="hljs-string">'paren'</span> &amp;&amp; token.value !== <span class="hljs-string">')'</span>)
      ) {
        <span class="hljs-regexp">//</span> 我们调用 `walk` 函数，它将会返回一个结点，然后我们把这个节点
        <span class="hljs-regexp">//</span> 放入 `node.params` 中。
        node.params.push(walk());
        token = tokens[current];
      }

      <span class="hljs-regexp">//</span> 我们最后一次增加 `current`，跳过右圆括号。
      current++;

      <span class="hljs-regexp">//</span> 返回结点。
      return node;
    }

    <span class="hljs-regexp">//</span> 同样，如果我们遇到了一个类型未知的结点，就抛出一个错误。
    throw new TypeError(token.type);
  }

  <span class="hljs-regexp">//</span> 现在，我们创建 AST，根结点是一个类型为 `Program` 的结点。
  var ast = {
    type: <span class="hljs-string">'Program'</span>,
    body: []
  };

  <span class="hljs-regexp">//</span> 现在我们开始 `walk` 函数，把结点放入 `ast.body` 中。
  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span> 之所以在一个循环中处理，是因为我们的程序可能在 `CallExpressions` 后面包含连续的两个
  <span class="hljs-regexp">//</span> 参数，而不是嵌套的。
  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span>   (add <span class="hljs-number">2</span> <span class="hljs-number">2</span>)
  <span class="hljs-regexp">//</span>   (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>)
  <span class="hljs-regexp">//</span>
  <span class="hljs-keyword">while</span> (current &lt; tokens.length) {
    ast.body.push(walk());
  }

  <span class="hljs-regexp">//</span> 最后我们的语法分析器返回 AST 
  return ast;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="遍历器"></a><a href="#遍历器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>遍历器!!!</h3>
<p>现在我们有了 AST，我们需要一个 visitor 去遍历所有的结点。当遇到某个类型的结点时，我们需要调用 visitor 中对应类型的处理函数。</p>
<pre><code class="hljs">    traverse(ast, {
      Program(<span class="hljs-keyword">node</span><span class="hljs-title">, parent</span>) {
        // ...
      },
 
      CallExpression(<span class="hljs-keyword">node</span><span class="hljs-title">, parent</span>) {
        // ...
      },
 
      NumberLiteral(<span class="hljs-keyword">node</span><span class="hljs-title">, parent</span>) {
        // ...
      }
    });

</code></pre>
<pre><code class="hljs"><span class="hljs-comment">// 所以我们定义一个遍历器，它有两个参数，AST 和 vistor。在它的里面我们又定义了两个函数...</span>
<span class="hljs-keyword">function</span> traverser(ast, visitor) {

  <span class="hljs-comment">// `traverseArray` 函数允许我们对数组中的每一个元素调用 `traverseNode` 函数。</span>
  <span class="hljs-keyword">function</span> traverse<span class="hljs-constructor">Array(<span class="hljs-params">array</span>, <span class="hljs-params">parent</span>)</span> {
    <span class="hljs-built_in">array</span>.for<span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">child</span>)</span> {
      traverse<span class="hljs-constructor">Node(<span class="hljs-params">child</span>, <span class="hljs-params">parent</span>)</span>;
    });
  }

  <span class="hljs-comment">// `traverseNode` 函数接受一个 `node` 和它的父结点 `parent` 作为参数，这个结点会被</span>
  <span class="hljs-comment">// 传入到 visitor 中相应的处理函数那里。</span>
  <span class="hljs-keyword">function</span> traverse<span class="hljs-constructor">Node(<span class="hljs-params">node</span>, <span class="hljs-params">parent</span>)</span> {

    <span class="hljs-comment">// 首先我们看看 visitor 中有没有对应 `type` 的处理函数。</span>
    var <span class="hljs-keyword">method</span> = visitor<span class="hljs-literal">[<span class="hljs-identifier">node</span>.<span class="hljs-identifier">type</span>]</span>;

    <span class="hljs-comment">// 如果有，那么我们把 `node` 和 `parent` 都传入其中。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>) {
      <span class="hljs-keyword">method</span>(node, parent);
    }

    <span class="hljs-comment">// 下面我们对每一个不同类型的结点分开处理。</span>
    switch (node.<span class="hljs-keyword">type</span>) {

      <span class="hljs-comment">// 我们从顶层的 `Program` 开始，Program 结点中有一个 body 属性，它是一个由若干</span>
      <span class="hljs-comment">// 个结点组成的数组，所以我们对这个数组调用 `traverseArray`。</span>
      <span class="hljs-comment">//</span>
      <span class="hljs-comment">// （记住 `traverseArray` 会调用 `traverseNode`，所以我们会递归地遍历这棵树。）</span>
      case 'Program':
        traverse<span class="hljs-constructor">Array(<span class="hljs-params">node</span>.<span class="hljs-params">body</span>, <span class="hljs-params">node</span>)</span>;
        break;

      <span class="hljs-comment">// 下面我们对 `CallExpressions` 做同样的事情，遍历它的 `params`。</span>
      case 'CallExpression':
        traverse<span class="hljs-constructor">Array(<span class="hljs-params">node</span>.<span class="hljs-params">params</span>, <span class="hljs-params">node</span>)</span>;
        break;

      <span class="hljs-comment">// 如果是 `NumberLiterals`，那么就没有任何子结点了，所以我们直接 break</span>
      case 'NumberLiteral':
        break;

      <span class="hljs-comment">// 同样，如果我们不能识别当前的结点，那么就抛出一个错误。</span>
      default:
        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(<span class="hljs-params">node</span>.<span class="hljs-params">type</span>)</span>;
    }
  }

  <span class="hljs-comment">// 最后我们对 AST 调用 `traverseNode`，开始遍历。注意 AST 并没有父结点。</span>
  traverse<span class="hljs-constructor">Node(<span class="hljs-params">ast</span>, <span class="hljs-params">null</span>)</span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="转换器"></a><a href="#转换器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换器!!!</h3>
<p>下面是转换器。转换器接收我们在之前构建好的 AST，然后把它和 visitor 传递进入我们的遍历器中 ，最后得到一个新的 AST。</p>
<pre><code class="hljs">
 *            原始的 AST               |               转换后的 AST
 * ----------------------------------------------------------------------------
 *   {                                |   {
 *     <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>,               |     <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>,
 *     <span class="hljs-string">body:</span> [{                       |     <span class="hljs-string">body:</span> [{
 *       <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,      |       <span class="hljs-string">type:</span> <span class="hljs-string">'ExpressionStatement'</span>,
 *       <span class="hljs-string">name:</span> <span class="hljs-string">'add'</span>,                 |       <span class="hljs-string">expression:</span> {
 *       <span class="hljs-string">params:</span> [{                   |         <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
 *         <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,     |         <span class="hljs-string">callee:</span> {
 *         <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>                 |           <span class="hljs-string">type:</span> <span class="hljs-string">'Identifier'</span>,
 *       }, {                         |           <span class="hljs-string">name:</span> <span class="hljs-string">'add'</span>
 *         <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,    |         },
 *         <span class="hljs-string">name:</span> <span class="hljs-string">'subtract'</span>,          |         <span class="hljs-string">arguments:</span> [{
 *         <span class="hljs-string">params:</span> [{                 |           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
 *           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,   |           <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
 *           <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>               |         }, {
 *         }, {                       |           <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
 *           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,   |           <span class="hljs-string">callee:</span> {
 *           <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>               |             <span class="hljs-string">type:</span> <span class="hljs-string">'Identifier'</span>,
 *         }]                         |             <span class="hljs-string">name:</span> <span class="hljs-string">'subtract'</span>
 *       }]                           |           },
 *     }]                             |           <span class="hljs-string">arguments:</span> [{
 *   }                                |             <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
 *                                    |             <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>
 * ---------------------------------- |           }, {
 *                                    |             <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
 *                                    |             <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
 *                                    |           }]
 *         (那一边比较长/w\)            |         }]
 *                                    |       }
 *                                    |     }]
 *                                    |   }
 * ----------------------------------------------------------------------------

</code></pre>
<pre><code class="hljs"><span class="hljs-comment">// 定义我们的转换器函数，接收 AST 作为参数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span><span class="hljs-params">(ast)</span> {</span>

  <span class="hljs-comment">// 创建 `newAST`，它与我们之前的 AST 类似，有一个类型为 Program 的根节点。</span>
  var newAst = {
    <span class="hljs-built_in">type</span>: <span class="hljs-string">'Program'</span>,
    body: []
  };

  <span class="hljs-comment">// 下面的代码会有些奇技淫巧，我们在父结点上使用一个属性 `context`（上下文），这样我们就</span>
  <span class="hljs-comment">// 可以把结点放入他们父结点的 context 中。当然可能会有更好的做法，但是为了简单我们姑且</span>
  <span class="hljs-comment">// 这么做吧。</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 注意 context 是一个*引用*，从旧的 AST 到新的 AST。</span>
  ast._context = newAst.body;

  <span class="hljs-comment">// 我们把 AST 和 visitor 函数传入遍历器</span>
  traverser(ast, {

    <span class="hljs-comment">// 第一个 visitor 方法接收 `NumberLiterals`。</span>
    NumberLiteral: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, parent)</span> {</span>

      <span class="hljs-comment">// 我们创建一个新结点，名字叫 `NumberLiteral`，并把它放入父结点的 context 中。</span>
      parent._context.push({
        <span class="hljs-built_in">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
        value: node.value
      });
    },

    <span class="hljs-comment">// 下一个，`CallExpressions`。</span>
    CallExpression: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, parent)</span> {</span>

      <span class="hljs-comment">// 我们创建一个 `CallExpression` 结点，里面有一个嵌套的 `Identifier`。</span>
      var expression = {
        <span class="hljs-built_in">type</span>: <span class="hljs-string">'CallExpression'</span>,
        callee: {
          <span class="hljs-built_in">type</span>: <span class="hljs-string">'Identifier'</span>,
          name: node.name
        },
        arguments: []
      };

      <span class="hljs-comment">// 下面我们在原来的 `CallExpression` 结点上定义一个新的 context，它是 expression</span>
      <span class="hljs-comment">// 中 arguments 这个数组的引用，我们可以向其中放入参数。</span>
      node._context = expression.arguments;

      <span class="hljs-comment">// 然后来看看父结点是不是一个 `CallExpression`，如果不是...</span>
      <span class="hljs-keyword">if</span> (parent.<span class="hljs-built_in">type</span> !== <span class="hljs-string">'CallExpression'</span>) {

        <span class="hljs-comment">// 我们把 `CallExpression` 结点包在一个 `ExpressionStatement` 中，这么做是因为</span>
        <span class="hljs-comment">// 单独存在（原文为top level）的 `CallExpressions` 在 JavaScript 中也可以被当做</span>
        <span class="hljs-comment">// 是声明语句。</span>
        <span class="hljs-comment">// </span>
        <span class="hljs-comment">// 译者注：比如 `var a = foo()` 与 `foo()`，后者既可以当作表达式给某个变量赋值，也</span>
        <span class="hljs-comment">// 可以作为一个独立的语句存在。</span>
        expression = {
          <span class="hljs-built_in">type</span>: <span class="hljs-string">'ExpressionStatement'</span>,
          expression: expression
        };
      }

      <span class="hljs-comment">// 最后我们把 `CallExpression`（可能是被包起来的） 放入父结点的 context 中。</span>
      parent._context.push(expression);
    }
  });

  <span class="hljs-comment">// 最后返回创建好的新 AST。</span>
  <span class="hljs-keyword">return</span> newAst;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="代码生成器"></a><a href="#代码生成器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码生成器!!!!</h3>
<p>现在只剩最后一步啦：代码生成器。我们的代码生成器会递归地调用它自己，把 AST 中的每个结点打印到一个很大的字符串中。</p>
<pre><code class="hljs"><span class="hljs-function">function <span class="hljs-title">codeGenerator</span>(<span class="hljs-params">node</span>)</span> {

  <span class="hljs-comment">// 对于不同 `type` 的结点分开处理。</span>
  <span class="hljs-keyword">switch</span> (node.type) {

    <span class="hljs-comment">// 如果是 `Program` 结点，那么我们会遍历它的 `body` 属性中的每一个结点，并且递归地</span>
    <span class="hljs-comment">// 对这些结点再次调用 codeGenerator，再把结果打印进入新的一行中。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Program'</span>:
      <span class="hljs-keyword">return</span> node.body.map(codeGenerator)
        .<span class="hljs-keyword">join</span>(<span class="hljs-string">'\n'</span>);

    <span class="hljs-comment">// 对于 `ExpressionStatements`,我们对它的 expression 属性递归调用，同时加入一个</span>
    <span class="hljs-comment">// 分号。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ExpressionStatement'</span>:
      <span class="hljs-keyword">return</span> (
        codeGenerator(node.expression) +
        <span class="hljs-string">';'</span> <span class="hljs-comment">// &lt;&lt; (...因为我们喜欢用*正确*的方式写代码)</span>
      );

    <span class="hljs-comment">// 对于 `CallExpressions`，我们会打印出 `callee`，接着是一个左圆括号，然后对</span>
    <span class="hljs-comment">// arguments 递归调用 codeGenerator，并且在它们之间加一个逗号，最后加上右圆括号。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CallExpression'</span>:
      <span class="hljs-keyword">return</span> (
        codeGenerator(node.callee) +
        <span class="hljs-string">'('</span> +
        node.arguments.map(codeGenerator)
          .<span class="hljs-keyword">join</span>(<span class="hljs-string">', '</span>) +
        <span class="hljs-string">')'</span>
      );

    <span class="hljs-comment">// 对于 `Identifiers` 我们只是返回 `node` 的 name。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Identifier'</span>:
      <span class="hljs-keyword">return</span> node.name;

    <span class="hljs-comment">// 对于 `NumberLiterals` 我们只是返回 `node` 的 value</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'NumberLiteral'</span>:
      <span class="hljs-keyword">return</span> node.<span class="hljs-keyword">value</span>;

    <span class="hljs-comment">// 如果我们不能识别这个结点，那么抛出一个错误。</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(node.type);
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="编译器"></a><a href="#编译器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>!!!!!!!!!!!!编译器!!!!!!!!!!!</h3>
<p>最后！我们创建 <code>compiler</code> 函数，它只是把上面说到的那些函数连接到一起。</p>
<ul>
<li><ol>
<li>input  =&gt; tokenizer   =&gt; tokens</li>
</ol></li>
<li><ol start="2">
<li>tokens =&gt; parser      =&gt; ast</li>
</ol></li>
<li><ol start="3">
<li>ast    =&gt; transformer =&gt; newAst</li>
</ol></li>
<li><ol start="4">
<li>newAst =&gt; generator   =&gt; output</li>
</ol></li>
</ul>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compiler</span></span>(input) {
  <span class="hljs-keyword">var</span> tokens = tokenizer(input);
  <span class="hljs-keyword">var</span> ast    = parser(tokens);
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Ast</span> = transformer(ast);
  <span class="hljs-keyword">var</span> output = codeGenerator(<span class="hljs-keyword">new</span><span class="hljs-type">Ast</span>);

  <span class="hljs-comment">// 然后返回输出!</span>
  <span class="hljs-keyword">return</span> output;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="你做到了"></a><a href="#你做到了" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>你做到了</h3>
<pre><code class="hljs"><span class="hljs-comment">// 现在导出所有接口...</span>
module.exports = {
<span class="hljs-symbol">  tokenizer:</span> tokenizer,
<span class="hljs-symbol">  parser:</span> parser,
<span class="hljs-symbol">  transformer:</span> transformer,
<span class="hljs-symbol">  codeGenerator:</span> codeGenerator,
<span class="hljs-symbol">  compiler:</span> compiler
};
</code></pre>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog">Recent Posts</a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 Go7hic</section></footer></div></body></html>