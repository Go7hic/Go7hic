<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · Go7hic</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Welcome to Go7hic&#x27;s homepage"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · Go7hic"/><meta property="og:type" content="website"/><meta property="og:url" content="https://yongyuan.us/"/><meta property="og:description" content="Welcome to Go7hic&#x27;s homepage"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/tx.jpeg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://yongyuan.us/blog/atom.xml" title="Go7hic Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://yongyuan.us/blog/feed.xml" title="Go7hic Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/tx.jpeg" alt="Go7hic"/><h2 class="headerTitleWithLogo">Go7hic</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/blog/" target="_self">blog</a></li><li class=""><a href="/docs/technology/doc1" target="_self">docs</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2018/03/10/web-sec-check-list">Web Developer Security Checklist【译】</a></li><li class="navListItem"><a class="navItem" href="/blog/2017/10/08/js-compiler">用 JavaScript 写一个简单的编译器【译】</a></li><li class="navListItem"><a class="navItem" href="/blog/2017/04/10/react-fiber">React Fiber 架构【译】</a></li><li class="navListItem"><a class="navItem" href="/blog/2016/09/17/ios-dev-3">写给前端的 iOS 开发教程(3)：iOS 与 ReactNative 混合开发</a></li><li class="navListItem"><a class="navItem" href="/blog/2016/09/17/ios-dev-2">写给前端的 iOS 开发教程(2)：熟悉 CocoaPods</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2018/03/10/web-sec-check-list">Web Developer Security Checklist【译】</a></h1><p class="post-meta">March 10, 2018</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="数据库"></a><a href="#数据库" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数据库</h3>
<ul>
<li>对识别用户身份的数据和诸如访问令牌、电子邮箱地址或账单明细等敏感数据进行加密。</li>
<li>如果数据库支持在空闲状态进行低消耗的数据加密 (如 <a href="https://aws.amazon.com/about-aws/whats-new/2015/12/amazon-aurora-now-supports-encryption-at-rest/">AWS Aurora</a>)，那么请激活此功能以加强磁盘数据安全。确保所有的备份文件也都被加密存储。</li>
<li>对访问数据库的用户帐号使用最小权限原则，禁止使用数据库 root 帐号。</li>
<li>使用精心设计的密钥库存储和分发密钥，不要对应用中使用的密钥进行硬编码。</li>
<li>仅使用 SQL 预备语句以彻底阻止 SQL 注入。例如，如果使用 NPM 开发应用，连接数据库时不使用 npm-mysql ，而是使用支持预备语句的 npm-mysql2 。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="开发"></a><a href="#开发" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>开发</h3>
<ul>
<li>确保已经检查过软件投入生存环境使用的每个版本中所有组件的漏洞，包括操作系统、库和软件包。此操作应该以自动化的方式加入 CI/CD（持续集成/持续部署） 过程。</li>
<li>对开发环境系统的安全问题保持与生产环境同样的警惕，从安全、独立的开发环境系统构建软件。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="认证-authentication"></a><a href="#认证-authentication" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>认证 (Authentication)</h3>
<ul>
<li>确保所有的密码都使用例如 bcrypt 之类的合适的加密算法进行哈希。绝对不要使用自己写的加密算法，并正确地使用随机数初始化加密算法。</li>
<li>使用简单但充分的密码规则以激励用户设置长的随机密码。</li>
<li>使用多因素身份验证方式实现对服务提供商的登录操作。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="拒绝服务防卫"></a><a href="#拒绝服务防卫" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拒绝服务防卫</h3>
<ul>
<li>确保对 API 进行 DOS 攻击不会让你的网站崩溃。至少增加速率限制到执行时间较长的 API 路径（例如登录、令牌生成等程序）。</li>
<li>对用户提交的数据和请求在大小和结构上增强完整性限制。</li>
<li>使用类似 CloudFlare 的全局缓存代理服务应用以缓解 Distributed Denial of Service （DDOS，分布式拒绝服务攻击）对网站带来的影响。它会在你遭受 DDOS 攻击时被激活，并且还具有类似 DNS 查找等功能。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="网络交通"></a><a href="#网络交通" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>网络交通</h3>
<ul>
<li>整个网站使用 TLS （安全传输层协议），不要仅对登录表单使用 TLS。</li>
<li>Cookies 必须添加 httpOnly 和 secure 属性，且由属性 path 和 domain 限定作用范围。</li>
<li>使用 CSP（内容安全策略） 以禁止不安全的后门操作。策略的配置很繁琐，但是值得。</li>
<li>使用 X-Frame-Option 和 X-XSS-Protection 响应头。</li>
<li>使用 HSTS(HTTP Strict Transport Security) 响应强迫客户端仅使用 TLS 访问服务器，同时服务端需要将所有 HTTP 请求重定向为 HTTPS。</li>
<li>在所有表单中使用 CSRF 令牌，使用新响应头 SameSite Cookie 一次性解决 CSRF 问题， SameSite Cookie 适用于所有新版本的浏览器。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="apis"></a><a href="#apis" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>APIs</h3>
<ul>
<li>确保公有 API 中没有可枚举的资源。</li>
<li>确保每个访问 API 的用户都能被恰当地认证和授权。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="校验"></a><a href="#校验" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>校验</h3>
<ul>
<li>使用客户端输入校验以及时给予用户反馈，但是不能完全信任客户端校验结果。</li>
<li>使用服务器的白名单校验用户输入。不要直接向响应注入用户信息，切勿在 SQL 语句里使用用户输入。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="云端配置"></a><a href="#云端配置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>云端配置</h3>
<ul>
<li>确保所有服务开放最少的端口。尽管通过隐藏信息来保障安全是不可靠的，使用非标准端口将使黑客的攻击操作更加困难。</li>
<li>在对任何公有网络都不可见的私有 VPC 上部署后台数据库和服务。在配置 AWS 安全组和对等互联多个 VPC 时务必谨慎（可能无意间使服务对外部可见）。</li>
<li>不同逻辑的服务部署在不同的 VPC 上，VPC 之间通过对等连接进行内部服务的访问。</li>
<li>让连接服务的 IP 地址个数尽可能少。</li>
<li>限制对外输出的 IP 和端口流量，以最小化 APT（高级持续性威胁）和“警告”。</li>
<li>始终使用 AWS 的 IAM（身份与访问管理）角色，而不是使用 root 的认证信息。</li>
<li>对所有操作和开发人员使用最小访问权限原则。</li>
<li>按照预定计划定期轮换密码和访问密钥。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="基础架构"></a><a href="#基础架构" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基础架构</h3>
<ul>
<li>确保在不停机的情况下对基础架构进行升级，确保以全自动的方式快速更新软件。</li>
<li>利用 Terraform 等工具创建所有的基础架构，而不是通过云端命令行窗口。基础架构应该代码化，仅需一个按钮的功夫即可重建。请不要手动在云端创建资源，因为使用 Terraform 就可以通过配置自动创建它们。</li>
<li>为所有服务使用集中化的日志记录，不该再利用 SSH 访问或检索日志。</li>
<li>除了一次性诊断服务故障以外，不要使用 SSH 登录进服务。频繁使用 SSH ，意味着你还没将执行重要任务的操作自动化。</li>
<li>不要长期开放任何 AWS 服务组的22号端口。</li>
<li>创建 immutable hosts（不可变主机） 而不是使用一个经过你长期提交补丁和更新的服务器。。（详情请看博客 Immutable Infrastructure Can Be More Secure）。</li>
<li>使用如 SenseDeep 的 Intrusion Detection System（入侵检测系统） 或服务，以最小化 APTs（高级持续性威胁） 。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="操作"></a><a href="#操作" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>操作</h3>
<p>关闭未使用的服务和服务器，关闭的服务器是最安全的。</p>
<h3><a class="anchor" aria-hidden="true" id="测试"></a><a href="#测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试</h3>
<ul>
<li>审核你的设计与实现。</li>
<li>进行渗透测试 — 攻击自己的应用，让其他人为你的应用编写测试代码。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="最后-制定计划"></a><a href="#最后-制定计划" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最后，制定计划</h3>
<ul>
<li>准备用于描述网络攻击防御的威胁模型，列出可能的威胁和网络攻击参与者，并按优先级对其排序。
-制定经得起实践考验的安全事故计划，总有一天你会用到它。</li>
</ul>
<p>原文地址：<a href="https://simplesecurity.sensedeep.com/web-developer-security-checklist-f2e4f43c9c56">https://simplesecurity.sensedeep.com/web-developer-security-checklist-f2e4f43c9c56</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2017/10/08/js-compiler">用 JavaScript 写一个简单的编译器【译】</a></h1><p class="post-meta">October 8, 2017</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>注：本文来自 <a href="https://github.com/thejameskyle/the-super-tiny-compiler">https://github.com/thejameskyle/the-super-tiny-compiler</a></p>
<blockquote>
<p>这是一个超级简单的编译器的例子，包含了现代编译器的几个主要部分，用简单易读的 JavaScript 编写。</p>
</blockquote>
<p>把这个读完将会有助于你了解大多数编译器从前端到后端是如何工作的。</p>
<p>今天让我们来写一个编译器，一个超级无敌小的编译器！它小到如果把所有注释删去的话，大概只剩 200行左右的代码。 我们将会用它将 lisp 风格的函数调用转换为 C 风格。 如果你对这两种风格不是很熟悉，下面是一个简单的介绍。 假设我们有两个函数，<code>add</code> 和 <code>subtract</code>，那么它们的写法将会是下面这样：</p>
<pre><code class="hljs">                   LISP                      C
 
    <span class="hljs-number">2</span> + <span class="hljs-number">2</span>          (add <span class="hljs-number">2</span> <span class="hljs-number">2</span>)                 add(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
    <span class="hljs-number">4</span> - <span class="hljs-number">2</span>          (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>)            subtract(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>)
    <span class="hljs-number">2</span> + (<span class="hljs-number">4</span> - <span class="hljs-number">2</span>)    (add <span class="hljs-number">2</span> (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>))    add(<span class="hljs-number">2</span>, subtract(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>))
 
</code></pre>
<p>很简单对吧？</p>
<p>这个转换就是我们将要做的事情。虽然这并不包含 LISP 或者 C 的全部语法，但它足以向我们展示现代编译器很多要点。</p>
<p>大多数编译器可以分成三个阶段：解析（Parsing），转换（Transformation）以及代码生成（Code Generation）</p>
<ul>
<li><ol>
<li><em>解析</em>是将最初原始的代码转换为一种更加抽象的表示（译者注：即AST）。*</li>
</ol></li>
<li><ol start="2">
<li><em>转换</em>将对这个抽象的表示做一些处理，让它能做到编译器期望它做到的事情。</li>
</ol></li>
<li><ol start="3">
<li><em>代码生成</em>接收处理之后的代码表示，然后把它转换成新的代码。</li>
</ol></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="解析-parsing"></a><a href="#解析-parsing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>解析 Parsing</h3>
<p>解析一般来说会分成两个阶段：词法分析（Lexical Analysis）和语法分析（Syntactic Analysis）。</p>
<ol>
<li><p><em>词法分析</em>接收原始代码，然后把它分割成一些被称为 Token 的东西，这个过程是在词法分析器（Tokenizer或者Lexer）中完成的。</p>
<p>Token 是一个数组，由一些代码语句的碎片组成。它们可以是数字、标签、标点符号、运算符，
或者其它任何东西。</p></li>
<li><p><em>语法分析</em> 接收之前生成的 Token，把它们转换成一种抽象的表示，这种抽象的表示描述了代
码语句中的每一个片段以及它们之间的关系。这被称为中间表示（intermediate representation）
或抽象语法树（Abstract Syntax Tree， 缩写为AST）</p>
<p>抽象语法树是一个嵌套程度很深的对象，用一种更容易处理的方式代表了代码本身，也能给我们
更多信息。</p></li>
</ol>
<p>比如说对于下面这一行代码语句：</p>
<pre><code class="hljs"> (<span class="hljs-name">add</span> <span class="hljs-number">2</span> (<span class="hljs-name">subtract</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span>))
</code></pre>
<p>它产生的 Token 看起来或许是这样的：</p>
<pre><code class="hljs">   [
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">'('</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'name'</span>,   <span class="hljs-string">value:</span> <span class="hljs-string">'add'</span>      },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'number'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">'('</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'name'</span>,   <span class="hljs-string">value:</span> <span class="hljs-string">'subtract'</span> },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'number'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'number'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">')'</span>        },
     { <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>,  <span class="hljs-string">value:</span> <span class="hljs-string">')'</span>        }
   ]
</code></pre>
<p>它的抽象语法树（AST）看起来或许是这样的：</p>
<pre><code class="hljs">*
*   {
*     <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>,
*     <span class="hljs-string">body:</span> [{
*       <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
*       <span class="hljs-string">name:</span> <span class="hljs-string">'add'</span>,
*       <span class="hljs-string">params:</span> [{
*         <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
*         <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
*       }, {
*         <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
*         <span class="hljs-string">name:</span> <span class="hljs-string">'subtract'</span>,
*         <span class="hljs-string">params:</span> [{
*           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
*           <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>
*         }, {
*           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
*           <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
*         }]
*       }]
*     }]
*   }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="转换-transformation"></a><a href="#转换-transformation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换（Transformation）</h3>
<p>编译器的下一步就是转换。它只是把 AST 拿过来然后对它做一些修改。它可以在同种语言下操作 AST，也可以把 AST 翻译成全新的语言。</p>
<p>下面我们来看看该如何转换 AST。</p>
<p>你或许注意到了我们的 AST 中有很多相似的元素，这些元素都有 type 属性，它们被称为 AST 结点。这些结点含有若干属性，可以用于描述 AST 的部分信息。</p>
<p>比如下面是一个“NumberLiteral”结点：</p>
<pre><code class="hljs">{
    <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
    value: <span class="hljs-string">'2'</span>
}
</code></pre>
<p>又比如下面是一个“CallExpression”结点：</p>
<pre><code class="hljs">
 {
   <span class="hljs-attribute">type</span>: <span class="hljs-string">'CallExpression'</span>,
   name: <span class="hljs-string">'subtract'</span>,
   params: [...nested nodes go here...]
}

</code></pre>
<p>当转换 AST 的时候我们可以添加、移动、替代这些结点，也可以根据现有的 AST 生成一个全新的 AST</p>
<p>既然我们编译器的目标是把输入的代码转换为一种新的语言，所以我们将会着重于产生一个针对新语言的全新的 AST。</p>
<h3><a class="anchor" aria-hidden="true" id="遍历-traversal"></a><a href="#遍历-traversal" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>遍历（Traversal）</h3>
<p>为了能处理所有的结点，我们需要遍历它们，使用的是深度优先遍历。</p>
<pre><code class="hljs">  {
     <span class="hljs-attribute">type</span>: <span class="hljs-string">'Program'</span>,
     <span class="hljs-attribute">body</span>: [{
       <span class="hljs-attribute">type</span>: <span class="hljs-string">'CallExpression'</span>,
       <span class="hljs-attribute">name</span>: <span class="hljs-string">'add'</span>,
       <span class="hljs-attribute">params</span>: [{
         <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
         <span class="hljs-attribute">value</span>: <span class="hljs-string">'2'</span>
      }, {
         <span class="hljs-attribute">type</span>: <span class="hljs-string">'CallExpression'</span>,
         <span class="hljs-attribute">name</span>: <span class="hljs-string">'subtract'</span>,
         <span class="hljs-attribute">params</span>: [{
            <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
            <span class="hljs-attribute">value</span>: <span class="hljs-string">'4'</span>
          }, {
            <span class="hljs-attribute">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
            <span class="hljs-attribute">value</span>: <span class="hljs-string">'2'</span>
          }]
        }]
      }]
   }
</code></pre>
<p>对于上面的 AST 的遍历流程是这样的：</p>
<ol>
<li>Program - 从 AST 的顶部结点开始</li>
<li>CallExpression (add) - Program 的第一个子元素</li>
<li>NumberLiteral (2) - CallExpression (add) 的第一个子元素</li>
<li>CallExpression (subtract) - CallExpression (add) 的第二个子元素</li>
<li>NumberLiteral (4) - CallExpression (subtract) 的第一个子元素</li>
<li>NumberLiteral (2) - CallExpression (subtract) 的第二个子元素</li>
</ol>
<p>如果我们直接在 AST 内部操作，而不是产生一个新的 AST，那么就要在这里介绍所有种类的抽象，</p>
<p>但是目前访问（visiting）所有结点的方法已经足够了。</p>
<p>使用“访问（visiting）”这个词的是因为这是一种模式，代表在对象结构内对元素进行操作。</p>
<h3><a class="anchor" aria-hidden="true" id="访问者-visitors"></a><a href="#访问者-visitors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问者（Visitors）</h3>
<p>我们最基础的想法是创建一个“访问者（visitor）”对象，这个对象中包含一些方法，可以接收不同的结点。</p>
<pre><code class="hljs"><span class="xml">   var visitor = </span><span class="hljs-template-variable">{
     NumberLiteral() {}</span><span class="xml">,
     CallExpression() </span><span class="hljs-template-variable">{}</span><span class="xml">
   };
</span></code></pre>
<p>当我们遍历 AST 的时候，如果遇到了匹配 type 的结点，我们可以调用 visitor 中的方法。</p>
<p>一般情况下为了让这些方法可用性更好，我们会把父结点也作为参数传入。</p>
<h3><a class="anchor" aria-hidden="true" id="代码生成-code-generation"></a><a href="#代码生成-code-generation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码生成（Code Generation）</h3>
<p>编译器的最后一个阶段是代码生成，这个阶段做的事情有时候会和转换（transformation）重叠，但是代码生成最主要的部分还是根据 AST 来输出代码。代码生成有几种不同的工作方式，有些编译器将会重用之前生成的 token，有些会创建独立的代码表示，以便于线性地输出代码。但是接下来我们还是着重于使用之前生成好的 AST。 我们的代码生成器需要知道如何“打印”AST 中所有类型的结点，然后它会递归地调用自身，直到所有代码都被打印到一个很长的字符串中。</p>
<p>好了！这就是编译器中所有的部分了。 当然不是说所有的编译器都像我说的这样。不同的编译器有不同的目的，所以也可能需要不同的步骤。 但你现在应该对编译器到底是个什么东西有个大概的认识了。
既然我全都解释一遍了，你应该能写一个属于自己的编译器了吧？哈哈开个玩笑，接下来才是重点 :P</p>
<p>所以我们开始吧...</p>
<h3><a class="anchor" aria-hidden="true" id="词法分析器-tokenizer"></a><a href="#词法分析器-tokenizer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>词法分析器（Tokenizer）!</h3>
<p>我们从第一个阶段开始，即词法分析，使用的是词法分析器（Tokenizer）。 我们只是接收代码组成的字符串，然后把它们分割成 token 组成的数组。</p>
<pre><code class="hljs">   (<span class="hljs-keyword">add</span><span class="bash"> 2 (subtract 4 2))   =&gt;   [{ <span class="hljs-built_in">type</span>: <span class="hljs-string">'paren'</span>, value: <span class="hljs-string">'('</span> }...]</span>
</code></pre>
<pre><code class="hljs">
<span class="hljs-comment">// 我们从接收一个字符串开始，首先设置两个变量。</span>
<span class="hljs-function">function <span class="hljs-title">tokenizer</span>(<span class="hljs-params">input</span>)</span> {

 <span class="hljs-comment">// `current`变量类似指针，用于记录我们在代码字符串中的位置。</span>
 <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;

 <span class="hljs-comment">// `tokens`数组是我们放置 token 的地方</span>
 <span class="hljs-keyword">var</span> tokens = [];

 <span class="hljs-comment">// 首先我们创建一个 `while` 循环， `current` 变量会在循环中自增。</span>
 <span class="hljs-comment">// </span>
 <span class="hljs-comment">// 我们这么做的原因是，由于 token 数组的长度是任意的，所以可能要在单个循环中多次</span>
 <span class="hljs-comment">// 增加 `current` </span>
 <span class="hljs-keyword">while</span> (current &lt; input.length) {

   <span class="hljs-comment">// 我们在这里储存了 `input` 中的当前字符</span>
   <span class="hljs-keyword">var</span> <span class="hljs-keyword">char</span> = input[current];

   <span class="hljs-comment">// 要做的第一件事情就是检查是不是右圆括号。这在之后将会用在 `CallExpressions` 中，</span>
   <span class="hljs-comment">// 但是现在我们关心的只是字符本身。</span>
   <span class="hljs-comment">//</span>
   <span class="hljs-comment">// 检查一下是不是一个左圆括号。</span>
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">char</span> === <span class="hljs-string">'('</span>) {

     <span class="hljs-comment">// 如果是，那么我们 push 一个 type 为 `paren`，value 为左圆括号的对象。</span>
     tokens.push({
       type: <span class="hljs-string">'paren'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-string">'('</span>
     });

     <span class="hljs-comment">// 自增 `current`</span>
     current++;

     <span class="hljs-comment">// 结束本次循环，进入下一次循环</span>
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 然后我们检查是不是一个右圆括号。这里做的时候和之前一样：检查右圆括号、加入新的 token、</span>
   <span class="hljs-comment">// 自增 `current`，然后进入下一次循环。</span>
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">char</span> === <span class="hljs-string">')'</span>) {
     tokens.push({
       type: <span class="hljs-string">'paren'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-string">')'</span>
     });
     current++;
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 继续，我们现在检查是不是空格。有趣的是，我们想要空格的本意是分隔字符，但这现在</span>
   <span class="hljs-comment">// 对于我们储存 token 来说不那么重要。我们暂且搁置它。</span>
   <span class="hljs-comment">// </span>
   <span class="hljs-comment">// 所以我们只是简单地检查是不是空格，如果是，那么我们直接进入下一个循环。</span>
   <span class="hljs-keyword">var</span> WHITESPACE = /\s/;
   <span class="hljs-keyword">if</span> (WHITESPACE.test(<span class="hljs-keyword">char</span>)) {
     current++;
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 下一个 token 的类型是数字。它和之前的 token 不同，因为数字可以由多个数字字符组成，</span>
   <span class="hljs-comment">// 但是我们只能把它们识别为一个 token。</span>
   <span class="hljs-comment">// </span>
   <span class="hljs-comment">//   (add 123 456)</span>
   <span class="hljs-comment">//        ^^^ ^^^</span>
   <span class="hljs-comment">//        Only two separate tokens</span>
   <span class="hljs-comment">//        这里只有两个 token</span>
   <span class="hljs-comment">//        </span>
   <span class="hljs-comment">// 当我们遇到一个数字字符时，将会从这里开始。</span>
   <span class="hljs-keyword">var</span> NUMBERS = /[<span class="hljs-number">0</span><span class="hljs-number">-9</span>]/;
   <span class="hljs-keyword">if</span> (NUMBERS.test(<span class="hljs-keyword">char</span>)) {

     <span class="hljs-comment">// 创建一个 `value` 字符串，用于 push 字符。</span>
     <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">''</span>;

     <span class="hljs-comment">// 然后我们循环遍历接下来的字符，直到我们遇到的字符不再是数字字符为止，把遇到的每</span>
     <span class="hljs-comment">// 一个数字字符 push 进 `value` 中，然后自增 `current`。</span>
     <span class="hljs-keyword">while</span> (NUMBERS.test(<span class="hljs-keyword">char</span>)) {
       <span class="hljs-keyword">value</span> += <span class="hljs-keyword">char</span>;
       <span class="hljs-keyword">char</span> = input[++current];
     }

     <span class="hljs-comment">// 然后我们把类型为 `number` 的 token 放入 `tokens` 数组中。</span>
     tokens.push({
       type: <span class="hljs-string">'number'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-keyword">value</span>
     });

     <span class="hljs-comment">// 进入下一次循环。</span>
     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 最后一种类型的 token 是 `name`。它由一系列的字母组成，这在我们的 lisp 语法中</span>
   <span class="hljs-comment">// 代表了函数。</span>
   <span class="hljs-comment">//</span>
   <span class="hljs-comment">//   (add 2 4)</span>
   <span class="hljs-comment">//    ^^^</span>
   <span class="hljs-comment">//    Name token</span>
   <span class="hljs-comment">//</span>
   <span class="hljs-keyword">var</span> LETTERS = /[a-z]/i;
   <span class="hljs-keyword">if</span> (LETTERS.test(<span class="hljs-keyword">char</span>)) {
     <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">''</span>;

     <span class="hljs-comment">// 同样，我们用一个循环遍历所有的字母，把它们存入 value 中。</span>
     <span class="hljs-keyword">while</span> (LETTERS.test(<span class="hljs-keyword">char</span>)) {
       <span class="hljs-keyword">value</span> += <span class="hljs-keyword">char</span>;
       <span class="hljs-keyword">char</span> = input[++current];
     }

     <span class="hljs-comment">// 然后添加一个类型为 `name` 的 token，然后进入下一次循环。</span>
     tokens.push({
       type: <span class="hljs-string">'name'</span>,
       <span class="hljs-keyword">value</span>: <span class="hljs-keyword">value</span>
     });

     <span class="hljs-keyword">continue</span>;
   }

   <span class="hljs-comment">// 最后如果我们没有匹配上任何类型的 token，那么我们抛出一个错误。</span>
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(<span class="hljs-string">'I dont know what this character is: '</span> + <span class="hljs-keyword">char</span>);
 }

 <span class="hljs-comment">// 词法分析器的最后我们返回 tokens 数组。</span>
 <span class="hljs-keyword">return</span> tokens;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="语法分析器-parser"></a><a href="#语法分析器-parser" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>语法分析器（Parser）!!!</h3>
<p>语法分析器接受 token 数组，然后把它转化为 AST</p>
<pre><code class="hljs">  [{ <span class="hljs-string">type:</span> <span class="hljs-string">'paren'</span>, <span class="hljs-string">value:</span> <span class="hljs-string">'('</span> }, ...]   =&gt;   { <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>, <span class="hljs-string">body:</span> [...] }
</code></pre>
<pre><code class="hljs"><span class="hljs-regexp">//</span> 现在我们定义 parser 函数，接受 `tokens` 数组
<span class="hljs-keyword">function</span> parser(tokens) {

  <span class="hljs-regexp">//</span> 我们再次声明一个 `current` 变量作为指针。
  var current = <span class="hljs-number">0</span>;

  <span class="hljs-regexp">//</span> 但是这次我们使用递归而不是 `<span class="hljs-keyword">while</span>` 循环，所以我们定义一个 `walk` 函数。
  <span class="hljs-keyword">function</span> walk() {

    <span class="hljs-regexp">//</span> walk函数里，我们从当前token开始
    var token = tokens[current];

    <span class="hljs-regexp">//</span> 对于不同类型的结点，对应的处理方法也不同，我们从 `number` 类型的 token 开始。
    <span class="hljs-regexp">//</span> 检查是不是 `number` 类型
    <span class="hljs-keyword">if</span> (token.type === <span class="hljs-string">'number'</span>) {

      <span class="hljs-regexp">//</span> 如果是，`current` 自增。
      current++;

      <span class="hljs-regexp">//</span> 然后我们会返回一个新的 AST 结点 `NumberLiteral`，并且把它的值设为 token 的值。
      return {
        type: <span class="hljs-string">'NumberLiteral'</span>,
        value: token.value
      };
    }

    <span class="hljs-regexp">//</span> 接下来我们检查是不是 CallExpressions 类型，我们从左圆括号开始。
    <span class="hljs-keyword">if</span> (
      token.type === <span class="hljs-string">'paren'</span> &amp;&amp;
      token.value === <span class="hljs-string">'('</span>
    ) {

      <span class="hljs-regexp">//</span> 我们会自增 `current` 来跳过这个括号，因为括号在 AST 中是不重要的。
      token = tokens[++current];

      <span class="hljs-regexp">//</span> 我们创建一个类型为 `CallExpression` 的根节点，然后把它的 name 属性设置为当前
      <span class="hljs-regexp">//</span> token 的值，因为紧跟在左圆括号后面的 token 一定是调用的函数的名字。 
      var node = {
        type: <span class="hljs-string">'CallExpression'</span>,
        name: token.value,
        params: []
      };

      <span class="hljs-regexp">//</span> 我们再次自增 `current` 变量，跳过当前的 token 
      token = tokens[++current];

      <span class="hljs-regexp">//</span> 现在我们循环遍历接下来的每一个 token，直到我们遇到右圆括号，这些 token 将会
      <span class="hljs-regexp">//</span> 是 `CallExpression` 的 `params`（参数）
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 这也是递归开始的地方，我们采用递归的方式来解决问题，而不是去尝试解析一个可能有无限
      <span class="hljs-regexp">//</span> 层嵌套的结点。
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 为了更好地解释，我们来看看我们的 Lisp 代码。你会注意到 `add` 函数的参数有两个，
      <span class="hljs-regexp">//</span> 一个是数字，另一个是一个嵌套的 `CallExpression`，这个 `CallExpression` 中
      <span class="hljs-regexp">//</span> 包含了它自己的参数（两个数字）
      <span class="hljs-regexp">//</span>
      <span class="hljs-regexp">//</span>   (add <span class="hljs-number">2</span> (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>))
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 你也会注意到我们的 token 数组中有多个右圆括号。
      <span class="hljs-regexp">//</span>
      <span class="hljs-regexp">//</span>   [
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">'('</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'name'</span>,   value: <span class="hljs-string">'add'</span>      },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'number'</span>, value: <span class="hljs-string">'2'</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">'('</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'name'</span>,   value: <span class="hljs-string">'subtract'</span> },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'number'</span>, value: <span class="hljs-string">'4'</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'number'</span>, value: <span class="hljs-string">'2'</span>        },
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">')'</span>        }, &lt;&lt;&lt; 右圆括号
      <span class="hljs-regexp">//</span>     { type: <span class="hljs-string">'paren'</span>,  value: <span class="hljs-string">')'</span>        }  &lt;&lt;&lt; 右圆括号
      <span class="hljs-regexp">//</span>   ]
      <span class="hljs-regexp">//</span>
      <span class="hljs-regexp">//</span> 遇到嵌套的 `CallExpressions` 时，我们将会依赖嵌套的 `walk` 函数来
      <span class="hljs-regexp">//</span> 增加 `current` 变量
      <span class="hljs-regexp">//</span> 
      <span class="hljs-regexp">//</span> 所以我们创建一个 `<span class="hljs-keyword">while</span>` 循环，直到遇到类型为 `<span class="hljs-string">'paren'</span>`，值为右圆括号的 token。 
      <span class="hljs-keyword">while</span> (
        (token.type !== <span class="hljs-string">'paren'</span>) ||
        (token.type === <span class="hljs-string">'paren'</span> &amp;&amp; token.value !== <span class="hljs-string">')'</span>)
      ) {
        <span class="hljs-regexp">//</span> 我们调用 `walk` 函数，它将会返回一个结点，然后我们把这个节点
        <span class="hljs-regexp">//</span> 放入 `node.params` 中。
        node.params.push(walk());
        token = tokens[current];
      }

      <span class="hljs-regexp">//</span> 我们最后一次增加 `current`，跳过右圆括号。
      current++;

      <span class="hljs-regexp">//</span> 返回结点。
      return node;
    }

    <span class="hljs-regexp">//</span> 同样，如果我们遇到了一个类型未知的结点，就抛出一个错误。
    throw new TypeError(token.type);
  }

  <span class="hljs-regexp">//</span> 现在，我们创建 AST，根结点是一个类型为 `Program` 的结点。
  var ast = {
    type: <span class="hljs-string">'Program'</span>,
    body: []
  };

  <span class="hljs-regexp">//</span> 现在我们开始 `walk` 函数，把结点放入 `ast.body` 中。
  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span> 之所以在一个循环中处理，是因为我们的程序可能在 `CallExpressions` 后面包含连续的两个
  <span class="hljs-regexp">//</span> 参数，而不是嵌套的。
  <span class="hljs-regexp">//</span>
  <span class="hljs-regexp">//</span>   (add <span class="hljs-number">2</span> <span class="hljs-number">2</span>)
  <span class="hljs-regexp">//</span>   (subtract <span class="hljs-number">4</span> <span class="hljs-number">2</span>)
  <span class="hljs-regexp">//</span>
  <span class="hljs-keyword">while</span> (current &lt; tokens.length) {
    ast.body.push(walk());
  }

  <span class="hljs-regexp">//</span> 最后我们的语法分析器返回 AST 
  return ast;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="遍历器"></a><a href="#遍历器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>遍历器!!!</h3>
<p>现在我们有了 AST，我们需要一个 visitor 去遍历所有的结点。当遇到某个类型的结点时，我们需要调用 visitor 中对应类型的处理函数。</p>
<pre><code class="hljs">    traverse(ast, {
      Program(<span class="hljs-keyword">node</span><span class="hljs-title">, parent</span>) {
        // ...
      },
 
      CallExpression(<span class="hljs-keyword">node</span><span class="hljs-title">, parent</span>) {
        // ...
      },
 
      NumberLiteral(<span class="hljs-keyword">node</span><span class="hljs-title">, parent</span>) {
        // ...
      }
    });

</code></pre>
<pre><code class="hljs"><span class="hljs-comment">// 所以我们定义一个遍历器，它有两个参数，AST 和 vistor。在它的里面我们又定义了两个函数...</span>
<span class="hljs-keyword">function</span> traverser(ast, visitor) {

  <span class="hljs-comment">// `traverseArray` 函数允许我们对数组中的每一个元素调用 `traverseNode` 函数。</span>
  <span class="hljs-keyword">function</span> traverse<span class="hljs-constructor">Array(<span class="hljs-params">array</span>, <span class="hljs-params">parent</span>)</span> {
    <span class="hljs-built_in">array</span>.for<span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">child</span>)</span> {
      traverse<span class="hljs-constructor">Node(<span class="hljs-params">child</span>, <span class="hljs-params">parent</span>)</span>;
    });
  }

  <span class="hljs-comment">// `traverseNode` 函数接受一个 `node` 和它的父结点 `parent` 作为参数，这个结点会被</span>
  <span class="hljs-comment">// 传入到 visitor 中相应的处理函数那里。</span>
  <span class="hljs-keyword">function</span> traverse<span class="hljs-constructor">Node(<span class="hljs-params">node</span>, <span class="hljs-params">parent</span>)</span> {

    <span class="hljs-comment">// 首先我们看看 visitor 中有没有对应 `type` 的处理函数。</span>
    var <span class="hljs-keyword">method</span> = visitor<span class="hljs-literal">[<span class="hljs-identifier">node</span>.<span class="hljs-identifier">type</span>]</span>;

    <span class="hljs-comment">// 如果有，那么我们把 `node` 和 `parent` 都传入其中。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>) {
      <span class="hljs-keyword">method</span>(node, parent);
    }

    <span class="hljs-comment">// 下面我们对每一个不同类型的结点分开处理。</span>
    switch (node.<span class="hljs-keyword">type</span>) {

      <span class="hljs-comment">// 我们从顶层的 `Program` 开始，Program 结点中有一个 body 属性，它是一个由若干</span>
      <span class="hljs-comment">// 个结点组成的数组，所以我们对这个数组调用 `traverseArray`。</span>
      <span class="hljs-comment">//</span>
      <span class="hljs-comment">// （记住 `traverseArray` 会调用 `traverseNode`，所以我们会递归地遍历这棵树。）</span>
      case 'Program':
        traverse<span class="hljs-constructor">Array(<span class="hljs-params">node</span>.<span class="hljs-params">body</span>, <span class="hljs-params">node</span>)</span>;
        break;

      <span class="hljs-comment">// 下面我们对 `CallExpressions` 做同样的事情，遍历它的 `params`。</span>
      case 'CallExpression':
        traverse<span class="hljs-constructor">Array(<span class="hljs-params">node</span>.<span class="hljs-params">params</span>, <span class="hljs-params">node</span>)</span>;
        break;

      <span class="hljs-comment">// 如果是 `NumberLiterals`，那么就没有任何子结点了，所以我们直接 break</span>
      case 'NumberLiteral':
        break;

      <span class="hljs-comment">// 同样，如果我们不能识别当前的结点，那么就抛出一个错误。</span>
      default:
        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(<span class="hljs-params">node</span>.<span class="hljs-params">type</span>)</span>;
    }
  }

  <span class="hljs-comment">// 最后我们对 AST 调用 `traverseNode`，开始遍历。注意 AST 并没有父结点。</span>
  traverse<span class="hljs-constructor">Node(<span class="hljs-params">ast</span>, <span class="hljs-params">null</span>)</span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="转换器"></a><a href="#转换器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换器!!!</h3>
<p>下面是转换器。转换器接收我们在之前构建好的 AST，然后把它和 visitor 传递进入我们的遍历器中 ，最后得到一个新的 AST。</p>
<pre><code class="hljs">
 *            原始的 AST               |               转换后的 AST
 * ----------------------------------------------------------------------------
 *   {                                |   {
 *     <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>,               |     <span class="hljs-string">type:</span> <span class="hljs-string">'Program'</span>,
 *     <span class="hljs-string">body:</span> [{                       |     <span class="hljs-string">body:</span> [{
 *       <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,      |       <span class="hljs-string">type:</span> <span class="hljs-string">'ExpressionStatement'</span>,
 *       <span class="hljs-string">name:</span> <span class="hljs-string">'add'</span>,                 |       <span class="hljs-string">expression:</span> {
 *       <span class="hljs-string">params:</span> [{                   |         <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
 *         <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,     |         <span class="hljs-string">callee:</span> {
 *         <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>                 |           <span class="hljs-string">type:</span> <span class="hljs-string">'Identifier'</span>,
 *       }, {                         |           <span class="hljs-string">name:</span> <span class="hljs-string">'add'</span>
 *         <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,    |         },
 *         <span class="hljs-string">name:</span> <span class="hljs-string">'subtract'</span>,          |         <span class="hljs-string">arguments:</span> [{
 *         <span class="hljs-string">params:</span> [{                 |           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
 *           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,   |           <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
 *           <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>               |         }, {
 *         }, {                       |           <span class="hljs-string">type:</span> <span class="hljs-string">'CallExpression'</span>,
 *           <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,   |           <span class="hljs-string">callee:</span> {
 *           <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>               |             <span class="hljs-string">type:</span> <span class="hljs-string">'Identifier'</span>,
 *         }]                         |             <span class="hljs-string">name:</span> <span class="hljs-string">'subtract'</span>
 *       }]                           |           },
 *     }]                             |           <span class="hljs-string">arguments:</span> [{
 *   }                                |             <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
 *                                    |             <span class="hljs-string">value:</span> <span class="hljs-string">'4'</span>
 * ---------------------------------- |           }, {
 *                                    |             <span class="hljs-string">type:</span> <span class="hljs-string">'NumberLiteral'</span>,
 *                                    |             <span class="hljs-string">value:</span> <span class="hljs-string">'2'</span>
 *                                    |           }]
 *         (那一边比较长/w\)            |         }]
 *                                    |       }
 *                                    |     }]
 *                                    |   }
 * ----------------------------------------------------------------------------

</code></pre>
<pre><code class="hljs"><span class="hljs-comment">// 定义我们的转换器函数，接收 AST 作为参数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span><span class="hljs-params">(ast)</span> {</span>

  <span class="hljs-comment">// 创建 `newAST`，它与我们之前的 AST 类似，有一个类型为 Program 的根节点。</span>
  var newAst = {
    <span class="hljs-built_in">type</span>: <span class="hljs-string">'Program'</span>,
    body: []
  };

  <span class="hljs-comment">// 下面的代码会有些奇技淫巧，我们在父结点上使用一个属性 `context`（上下文），这样我们就</span>
  <span class="hljs-comment">// 可以把结点放入他们父结点的 context 中。当然可能会有更好的做法，但是为了简单我们姑且</span>
  <span class="hljs-comment">// 这么做吧。</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 注意 context 是一个*引用*，从旧的 AST 到新的 AST。</span>
  ast._context = newAst.body;

  <span class="hljs-comment">// 我们把 AST 和 visitor 函数传入遍历器</span>
  traverser(ast, {

    <span class="hljs-comment">// 第一个 visitor 方法接收 `NumberLiterals`。</span>
    NumberLiteral: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, parent)</span> {</span>

      <span class="hljs-comment">// 我们创建一个新结点，名字叫 `NumberLiteral`，并把它放入父结点的 context 中。</span>
      parent._context.push({
        <span class="hljs-built_in">type</span>: <span class="hljs-string">'NumberLiteral'</span>,
        value: node.value
      });
    },

    <span class="hljs-comment">// 下一个，`CallExpressions`。</span>
    CallExpression: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, parent)</span> {</span>

      <span class="hljs-comment">// 我们创建一个 `CallExpression` 结点，里面有一个嵌套的 `Identifier`。</span>
      var expression = {
        <span class="hljs-built_in">type</span>: <span class="hljs-string">'CallExpression'</span>,
        callee: {
          <span class="hljs-built_in">type</span>: <span class="hljs-string">'Identifier'</span>,
          name: node.name
        },
        arguments: []
      };

      <span class="hljs-comment">// 下面我们在原来的 `CallExpression` 结点上定义一个新的 context，它是 expression</span>
      <span class="hljs-comment">// 中 arguments 这个数组的引用，我们可以向其中放入参数。</span>
      node._context = expression.arguments;

      <span class="hljs-comment">// 然后来看看父结点是不是一个 `CallExpression`，如果不是...</span>
      <span class="hljs-keyword">if</span> (parent.<span class="hljs-built_in">type</span> !== <span class="hljs-string">'CallExpression'</span>) {

        <span class="hljs-comment">// 我们把 `CallExpression` 结点包在一个 `ExpressionStatement` 中，这么做是因为</span>
        <span class="hljs-comment">// 单独存在（原文为top level）的 `CallExpressions` 在 JavaScript 中也可以被当做</span>
        <span class="hljs-comment">// 是声明语句。</span>
        <span class="hljs-comment">// </span>
        <span class="hljs-comment">// 译者注：比如 `var a = foo()` 与 `foo()`，后者既可以当作表达式给某个变量赋值，也</span>
        <span class="hljs-comment">// 可以作为一个独立的语句存在。</span>
        expression = {
          <span class="hljs-built_in">type</span>: <span class="hljs-string">'ExpressionStatement'</span>,
          expression: expression
        };
      }

      <span class="hljs-comment">// 最后我们把 `CallExpression`（可能是被包起来的） 放入父结点的 context 中。</span>
      parent._context.push(expression);
    }
  });

  <span class="hljs-comment">// 最后返回创建好的新 AST。</span>
  <span class="hljs-keyword">return</span> newAst;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="代码生成器"></a><a href="#代码生成器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码生成器!!!!</h3>
<p>现在只剩最后一步啦：代码生成器。我们的代码生成器会递归地调用它自己，把 AST 中的每个结点打印到一个很大的字符串中。</p>
<pre><code class="hljs"><span class="hljs-function">function <span class="hljs-title">codeGenerator</span>(<span class="hljs-params">node</span>)</span> {

  <span class="hljs-comment">// 对于不同 `type` 的结点分开处理。</span>
  <span class="hljs-keyword">switch</span> (node.type) {

    <span class="hljs-comment">// 如果是 `Program` 结点，那么我们会遍历它的 `body` 属性中的每一个结点，并且递归地</span>
    <span class="hljs-comment">// 对这些结点再次调用 codeGenerator，再把结果打印进入新的一行中。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Program'</span>:
      <span class="hljs-keyword">return</span> node.body.map(codeGenerator)
        .<span class="hljs-keyword">join</span>(<span class="hljs-string">'\n'</span>);

    <span class="hljs-comment">// 对于 `ExpressionStatements`,我们对它的 expression 属性递归调用，同时加入一个</span>
    <span class="hljs-comment">// 分号。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ExpressionStatement'</span>:
      <span class="hljs-keyword">return</span> (
        codeGenerator(node.expression) +
        <span class="hljs-string">';'</span> <span class="hljs-comment">// &lt;&lt; (...因为我们喜欢用*正确*的方式写代码)</span>
      );

    <span class="hljs-comment">// 对于 `CallExpressions`，我们会打印出 `callee`，接着是一个左圆括号，然后对</span>
    <span class="hljs-comment">// arguments 递归调用 codeGenerator，并且在它们之间加一个逗号，最后加上右圆括号。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CallExpression'</span>:
      <span class="hljs-keyword">return</span> (
        codeGenerator(node.callee) +
        <span class="hljs-string">'('</span> +
        node.arguments.map(codeGenerator)
          .<span class="hljs-keyword">join</span>(<span class="hljs-string">', '</span>) +
        <span class="hljs-string">')'</span>
      );

    <span class="hljs-comment">// 对于 `Identifiers` 我们只是返回 `node` 的 name。</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Identifier'</span>:
      <span class="hljs-keyword">return</span> node.name;

    <span class="hljs-comment">// 对于 `NumberLiterals` 我们只是返回 `node` 的 value</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'NumberLiteral'</span>:
      <span class="hljs-keyword">return</span> node.<span class="hljs-keyword">value</span>;

    <span class="hljs-comment">// 如果我们不能识别这个结点，那么抛出一个错误。</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeError(node.type);
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="编译器"></a><a href="#编译器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>!!!!!!!!!!!!编译器!!!!!!!!!!!</h3>
<p>最后！我们创建 <code>compiler</code> 函数，它只是把上面说到的那些函数连接到一起。</p>
<ul>
<li><ol>
<li>input  =&gt; tokenizer   =&gt; tokens</li>
</ol></li>
<li><ol start="2">
<li>tokens =&gt; parser      =&gt; ast</li>
</ol></li>
<li><ol start="3">
<li>ast    =&gt; transformer =&gt; newAst</li>
</ol></li>
<li><ol start="4">
<li>newAst =&gt; generator   =&gt; output</li>
</ol></li>
</ul>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compiler</span></span>(input) {
  <span class="hljs-keyword">var</span> tokens = tokenizer(input);
  <span class="hljs-keyword">var</span> ast    = parser(tokens);
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Ast</span> = transformer(ast);
  <span class="hljs-keyword">var</span> output = codeGenerator(<span class="hljs-keyword">new</span><span class="hljs-type">Ast</span>);

  <span class="hljs-comment">// 然后返回输出!</span>
  <span class="hljs-keyword">return</span> output;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="你做到了"></a><a href="#你做到了" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>你做到了</h3>
<pre><code class="hljs"><span class="hljs-comment">// 现在导出所有接口...</span>
module.exports = {
<span class="hljs-symbol">  tokenizer:</span> tokenizer,
<span class="hljs-symbol">  parser:</span> parser,
<span class="hljs-symbol">  transformer:</span> transformer,
<span class="hljs-symbol">  codeGenerator:</span> codeGenerator,
<span class="hljs-symbol">  compiler:</span> compiler
};
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2017/04/10/react-fiber">React Fiber 架构【译】</a></h1><p class="post-meta">April 10, 2017</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>React v16 即将发布了，这个版本带来最大的变化就是核心 diff 算法的重写，在新版发布之前，我们一起来了解一下这个被叫做 fiber 的算法到底是啥。</p>
<p>原文地址：<a href="https://github.com/acdlite/react-fiber-architecture">https://github.com/acdlite/react-fiber-architecture</a></p>
<h2><a class="anchor" aria-hidden="true" id="介绍"></a><a href="#介绍" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>介绍</h2>
<p>React Fiber是一个正在重写的 React 核心算法。它是React团队过去两年研究的结晶。</p>
<p>React Fiber 的目标是增强对于某些领域的适应性，比如动画、布局和手势等。它的重要特性是增量渲染：将渲染事务分块并分布到多个帧去完成的能力。</p>
<p>其他关键特性包括有新的更新时，暂停、终止或重用事务的功能；为不同类型的更新设置优先级的功能；还有新的并发原语。</p>
<h2><a class="anchor" aria-hidden="true" id="关于本文档"></a><a href="#关于本文档" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于本文档</h2>
<p>Fiber 引入了几个新颖的概念，单单看代码是很难理解的。本文档起初是 React 项目在逐步实现 Fiber 的时候记的笔记集，随着慢慢扩充，我发现这对于其他人来说可能也是很实用的资源。</p>
<p>我会尽可能的使用简单的语言，通过显示的定义一些术语来避免行话。如果可能，我也会尽可能链接到外部资源。</p>
<p>注意我并不在React团队里面，不代表任何官方的发言。这不是官方文档。不过我请教了React团队的一些成员来检查文档的准确性。</p>
<p>这也是一项进行中的工作。Fiber也是一个开发中的项目，在完成之前有可能还会有重大的重构。所以我在此为它的设计写的文档也是进行中的。非常欢迎提出优化和建议。</p>
<p>我的目标是读完这篇文档后，你能够理解Fiber足够深来读懂它的实现，最终甚至能够返回来给React做一些贡献。</p>
<h2><a class="anchor" aria-hidden="true" id="需要的知识"></a><a href="#需要的知识" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>需要的知识</h2>
<p>我强烈建议在继续看本文档之前，你先熟悉一下以下资源：</p>
<ul>
<li><a href="https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html">React组件，元素和实例</a> -”组件“是经常提起的术语。对这些术语有坚实的认知是非常重要的。</li>
<li><a href="https://facebook.github.io/react/docs/reconciliation.html">协调算法</a> - React协调算法的高阶阐述。</li>
<li><a href="https://github.com/reactjs/react-basic">React基本理论概念</a> - 不带实现细节的React理论模型阐述。其中一些内容可能在第一次阅读时没什么意义，但随着时间推移会证明非常有用。</li>
<li><a href="https://facebook.github.io/react/contributing/design-principles.html">React设计原则</a> - 特别注意其中的Scheduling环节，它很好的诠释了React Fiber诞生的原因。</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="回顾"></a><a href="#回顾" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回顾</h2>
<p>如果你还没阅读“必要的知识”环节，请确认阅读一下。
在我们学习新的东西前，我们回顾一些概念。</p>
<h3><a class="anchor" aria-hidden="true" id="什么是协调算法-what-is-reconciliation"></a><a href="#什么是协调算法-what-is-reconciliation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是协调算法 （What is reconciliation）</h3>
<h4><a class="anchor" aria-hidden="true" id="协调算法reconciliation"></a><a href="#协调算法reconciliation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协调算法(reconciliation)</h4>
<blockquote>
<p>React用以比较两棵树的算法，其决定哪些部分需要更改。</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="更新update"></a><a href="#更新update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新(update)</h4>
<blockquote>
<p>即渲染React app的数据发生的一个改变。通常是setState的结果。最终会导致重新渲染。</p>
</blockquote>
<p>React API的核心思想是让更新能引发整个app及时的重新渲染。这将允许开发者作出声明式的推断，而不用担心app从一个状态切换到另一个状态时过渡的效率（A到B，B到C，C到A等等）。</p>
<p>实际上，对于每一次改变都重新渲染app只对一些小型应用有用；现实中，这是极度浪费性能的。React使用了一些优化，使得保持高性能的同时能够达到类似重新渲染整个app的效果。这些优化就是协调算法的一部分。</p>
<p>协调算法是基于通常被称为“虚拟DOM”技术的。一个高阶的描述是：当你渲染一个React app的时候，会生成app描述的节点树并保存在内存中。然后这个树被输出到渲染环境——比如，在浏览器应用中，它被翻译为一堆DOM操作。当一个app更新时（一般是通过setState），就产生了一棵新树。新树和旧树会进行比较，计算需要哪些操作来更新app。</p>
<p>虽然Fiber是协调算法的推倒重写，关于React文档)中的高阶知识还是一致的。主要的两点是：</p>
<ul>
<li>不同类型的组件很大程度上将会产生不同的树。React将不会比较他们，而是直接用新的完全替代旧的。</li>
<li>列表的diff使用key。Key应当是稳定、可预测、并且唯一的。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="协调算法-vs-渲染"></a><a href="#协调算法-vs-渲染" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协调算法 vs 渲染</h3>
<p>DOM 只是 React 可以输出的渲染环境之一，其他的一些主要目标包括通过React Native输出到原生的iOS和Android视图。（这也就是为什么“虚拟DOM”是有点用词不当的）</p>
<p>React支持这么多目标的原因是因为它将协调算法和渲染设计成了不同的阶段。协调算法负责计算一棵树哪些部分更改了；渲染器则利用该信息来实际更新app。</p>
<p>这个分离意味着 React DOM 和 React Native 能共享 React 核心提供的协调算法，而使用它们各自的渲染器。</p>
<p>Fiber重构了协调器。Fiber 不是渲染需要首要考虑的，但渲染器需要改变来支持（并且利用）新的架构。</p>
<h3><a class="anchor" aria-hidden="true" id="调度scheduling"></a><a href="#调度scheduling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调度(Scheduling)</h3>
<h4><a class="anchor" aria-hidden="true" id="调度scheduling-1"></a><a href="#调度scheduling-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调度(scheduling)</h4>
<p>决定事务什么时候执行的过程。</p>
<h4><a class="anchor" aria-hidden="true" id="事务work"></a><a href="#事务work" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>事务(work)</h4>
<p>必须执行的计算。事务一般是由update引起的（比如setState）。
React的设计原则文档在这方面写的很好，我引用如下：</p>
<blockquote>
<p>在当前的实现中，React递归遍历节点树，在一个tick内调用整棵新树的渲染函数。但是未来有可能推迟一些更新来避免掉帧。</p>
</blockquote>
<p>这是React设计的一个常见主题。一些流行的库采用&quot;push&quot;方法，在新的数据就绪的时候就执行计算。React仍然使用&quot;pull&quot;方法，计算可以推迟到需要的时候才执行。
React不是通用的数据处理库。它是用以建立用户界面的库。我们认为在一个app中，知道计算是相关还是不相关的是独一无二的重要。</p>
<p>如果某些东西超出了屏幕显示，我们可以延迟它相关的所有逻辑。如果数据到达的比帧率要快，我们可以合并和批处理更新。我们可以优先处理用户交互的事务（比如点击按钮引起的动画），次要处理没那么重要的背景事务（比如渲染刚从网络上返回的数据）来避免掉帧。</p>
<p>关键点在于：</p>
<ul>
<li>在用户界面中，没必要每一个更新都立即执行；实际上这样做是很浪费的，导致掉帧，降低用户体验。</li>
<li>不同类型的更新具有不同的优先级——一个动画更新需要比数据源的更新更快的完成。</li>
<li>一个基于push的app需要应用（你，程序员）来决定怎么调度事务。基于pull的app允许框架(React)变得智能化，帮你完成这些决策。</li>
</ul>
<p>React现在没有很重要地利用调度；一个更新会引发整个子树被立即重新渲染。革新React的核心算法来充分利用调度是Fiber背后的驱动想法。</p>
<p>现在我们已经准备好了深入Fiber的实现。下一节比我们前面讨论的都要更偏技术一点。继续之前，确认你学习好了前面的知识点。</p>
<h2><a class="anchor" aria-hidden="true" id="什么是fiber"></a><a href="#什么是fiber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是Fiber？</h2>
<p>我们将要讨论React Fiber架构的核心部分。Fibers是比应用开发者通常思考的部分要低很多的底层抽象。如果你发现很难理解它，不要丧气。多尝试几次，最终你就能理解。（如果你最后懂了，请提些建议来改进这节内容）</p>
<p>出发吧！</p>
<p>我们前面已经确定了Fiber的主要目标是使React能够充分利用调度。详细来说，我们需要能够：</p>
<ul>
<li>暂停事务，在一段时间后再接着执行。</li>
<li>分配不同类型事务的优先级。</li>
<li>复用之前已完成的事务。</li>
<li>当事务不再需要时，终止该事务。</li>
</ul>
<p>为了实现上面的任意一个功能，首先我们需要分解事务为若干单元的方法。在某种意义上那就是一个fiber。一个fiber- 代表了事务的一个单元。
更进一步之前，我们重温一下React组件是数据的函数的概念，通常表达为：</p>
<pre><code class="hljs"><span class="hljs-attr">v</span> = f(d)
</code></pre>
<p>它表明渲染一个React app类似于调用一个函数，这个函数体里面包含了对其他函数的调用，以此类推。这个类比在思考fiber的时候很有帮助。</p>
<p>计算机跟踪一个程序执行的方式是调用栈。当一个函数执行的时候，栈上面就会添加一个新的堆栈结构。这个堆栈结构代表了那个函数执行的事务。</p>
<p>处理用户界面时，问题是如果太多的事务同时执行，它可能导致动画掉帧，看起来卡顿。还有，其中的一些事务是不需要的，因为它可能被最近的更新取代了。这就是UI组件和函数的比较分解的地方，因为通常组件比函数有更详细的关注点。</p>
<p>最新的浏览器（和React Native）实现了API来定位这个问题：requestIdleCallback调度一个低优先级的函数在空闲阶段执行，requestAnimationFrame调度一个高优先级的函数在下一个动画帧执行。问题在于，要使用这些API，你需要将渲染事务分解为增量单元的方法。如果你仅依赖于调用栈，它将会一直工作直到栈变空。</p>
<p>如果我们能自定义调用栈的行为来优化UI渲染该多好啊？如果我们能主动中断调用栈，手动操作堆栈结构该多好啊？
那就是React Fiber的目的。Fiber是专门为React组件实现的堆栈重构。你可以把单个fiber当做一个虚拟的堆栈结构(virtual stack frame)。</p>
<p>重构堆栈的好处是你能保存堆栈结构在内存里，然后用你想要的方式和时机去执行它。这点对于实现我们要的调度功能非常
重要。</p>
<p>除了调度，手动操作堆栈结构也使的一些潜在特性变得可能，比如并发和错误边界。我们将会在未来的章节讨论这些话题。
下一节，我们将讨论更多关于fiber的结构。</p>
<h3><a class="anchor" aria-hidden="true" id="一个fiber的结构"></a><a href="#一个fiber的结构" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一个fiber的结构</h3>
<p>注意：随着我们讨论更多的实现细节，某些东西被改变的概率也会上升。如果你发现了任何错误或过时的信息，请帮忙提交一下PR。
具体来说，一个fiber是包含了一个组件及其输入、输出信息的JavaScript对象。
一个fiber对应了一个堆栈结构，同时它也对应了一个组件实例。
下面是fiber的一些重要字段。（这个列表不是完全的）</p>
<h4><a class="anchor" aria-hidden="true" id="type和key"></a><a href="#type和key" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>type和key</h4>
<p>fiber的type和key的作用和React元素一样。（实际上，一个fiber从组件创建时，这两个字段会直接复制过来）
fiber的type描述了它对应的组件。对于复合组件，type就是复合函数或组件的class。对于宿主组件（div, span等），type是一个字符串。
从概念上来说，type是执行会被堆栈结构跟踪的函数（即在v = f(d)里面的）。
除了type之外，key是在协调算法中用来决定fiber是否可以重用的字段。</p>
<h4><a class="anchor" aria-hidden="true" id="child和sibling"></a><a href="#child和sibling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>child和sibling</h4>
<p>这些字段指向其他的fiber，描述的是fiber的递归树结构。
子fiber(child fiber)指的是组件的render方法返回来的值。比如在下面的样例中Parent的子fiber就是Child。</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span>
}
</span></code></pre>
<p>兄弟fiber(sibling fiber)指代的是render方法返回多个子节点的情况（Fiber中的新特性！）：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> [<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child1</span> /&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> /&gt;</span>]
}
</span></code></pre>
<p>兄弟fiber形成一个单链表，链表头就是第一个子节点。在上面的例子中，Parent的子节点是Child1，Child1的兄弟节点是Child2。
回顾我们前面的函数类比，你可以把子fiber当做是一个尾调用函数。</p>
<h4><a class="anchor" aria-hidden="true" id="return"></a><a href="#return" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>return</h4>
<p>返回fiber(return fiber)是指程序处理完当前的fiber后应当处理的下一个fiber。理论上和一个堆栈结构的返回地址一样。也可以认为是父fiber。
如果一个fiber有多个子fiber，每个子fiber的返回fiber都是它的父fiber。所以在我们上一个例子中，Child1和Child2的返回fiber都是Parent。</p>
<h4><a class="anchor" aria-hidden="true" id="pendingprops和memoizedprops"></a><a href="#pendingprops和memoizedprops" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>pendingProps和memoizedProps</h4>
<p>概念上来说，props就是一个函数的参数。一个fiber的pendingProps会在它开始执行处设置，memoizedProps则会在执行结尾处设置。当到来的pendingProps和上一个memoizedProps相等时，它意味着fiber的上一次输出可以重用，避免不必要的事务。</p>
<h4><a class="anchor" aria-hidden="true" id="pendingworkpriority"></a><a href="#pendingworkpriority" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>pendingWorkPriority</h4>
<p>指示fiber代表的事务优先级的一个数字。React优先级模块列举了不同的优先级和它们代表的意义。
除了用0表示NoWork之外，越大的数字代表了越低的优先级。例如，你可以用下面的函数来检查一个fiber的优先级是不是不低于给定的等级：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchesPriority</span>(<span class="hljs-params">fiber, priority</span>) </span>{
  <span class="hljs-keyword">return</span> fiber.pendingWorkPriority !== <span class="hljs-number">0</span> &amp;&amp;
         fiber.pendingWorkPriority &lt;= priority
}
</code></pre>
<p>这个函数仅仅是作说明用，它实际上不属于React Fiber代码库。
调度器使用这个优先级字段来搜索下一个要执行的事务。搜索算法会在将来的章节讨论。</p>
<h3><a class="anchor" aria-hidden="true" id="alternate"></a><a href="#alternate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>alternate</h3>
<h4><a class="anchor" aria-hidden="true" id="flush"></a><a href="#flush" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>flush</h4>
<p>冲洗一个fiber就是渲染输出结果到屏幕上。</p>
<h4><a class="anchor" aria-hidden="true" id="work-in-progress"></a><a href="#work-in-progress" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>work-in-progress</h4>
<p>进行中的fiber代表一个未处理完毕的fiber，概念上来说就是一个还未返回的堆栈结构。</p>
<p>在任意一个时刻，一个组件实例最多有两个fiber对应着它：当前fiber，冲洗的fiber和进行中的fiber。</p>
<p>当前fiber的替代(alternate)就是进行中的fiber，进行中的fiber的替代就是当前fiber。</p>
<p>一个fiber的替代是通过cloneFiber函数懒创建的。cloneFiber会尝试重用fiber的替代（如果存在）来最小化分配空间，而不是总创建新的对象。</p>
<p>你应当把alternate当做是一个实现细节，但它在代码里面出现了很多次，所以值得在这里讨论。</p>
<h3><a class="anchor" aria-hidden="true" id="output"></a><a href="#output" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>output</h3>
<h4><a class="anchor" aria-hidden="true" id="host-component"></a><a href="#host-component" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>host component</h4>
<p>宿主组件(host component)是React应用的叶节点。它们是跟特定的渲染环境相关的（比如，在浏览器应用中，宿主组件是指div, span等）。在JSX中，它们是用小写字母的tag名称表示的。
概念上来说，一个fiber的输出结果就是一个函数的返回值。
每个fiber最终都会有输出结果，但是输出结果是仅由叶节点的宿主组件创建的。然后输出结果会向上转移到整个树。
输出结果就是最终交给渲染器的东西，然后渲染器能够将更改冲洗到渲染环境。定义输出结果怎么样创建和更新就是渲染器的职责了。</p>
<h2><a class="anchor" aria-hidden="true" id="未来的部分"></a><a href="#未来的部分" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>未来的部分</h2>
<p>上面就是至今为止的内容了，但是这个文档还远未接近完成。未来的内容将会描述贯穿整个生命周期和更新使用的算法。将覆盖的主题包括：</p>
<ul>
<li>调度器怎么样找到下一个要执行的事务单元</li>
<li>整个fiber树的优先级怎么跟踪和传播</li>
<li>调度器怎么样知道什么时候暂停和继续事务</li>
<li>事务是怎么冲洗和标记为完成的</li>
<li>附带后果（比如声明周期方法）是怎么样工作的</li>
<li>什么是协同程序，和它是怎么样用来实现一些特性比如上下文(context)和布局(layout)的</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="相关视频"></a><a href="#相关视频" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>相关视频</h2>
<p><a href="https://youtu.be/aV1271hd9ew">What's Next for React (ReactNext 2016)</a></p>
<h3><a class="anchor" aria-hidden="true" id="国内相关讨论"></a><a href="#国内相关讨论" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>国内相关讨论：</h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26027085">https://zhuanlan.zhihu.com/p/26027085</a></li>
<li><a href="https://www.zhihu.com/question/49496872">https://www.zhihu.com/question/49496872</a></li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/09/17/ios-dev-3">写给前端的 iOS 开发教程(3)：iOS 与 ReactNative 混合开发</a></h1><p class="post-meta">September 17, 2016</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>ReactNative 是啥我就不具体介绍了，作为前端你没用过也该听说过。从上半年开始一直断断续续写 RN，遇到 RN 和原生混合开发场景，当然 RN 理论上来说也可以理解为原生应用，只不过中间多了一层 JS 的编译，但是我这里的原生指的是 Objective-C 的原生 iOS 开发。</p>
<p>作为前端来讲从 RN 来学习 iOS 开发我觉得再合适不过了，下面就是一个 RN 结合原生的开发例子。</p>
<p>假设你已经有了一个原生应用，然后通过 <code>react-native init</code> 开始一个新的 RN 项目工程，把你的原生应用的代码全部放到 RN 项目的 ios 目录里面去。理论上来讲你的原生项目应该用了CocoaPods 来管理一些库，这样你可以在 pod 里面把 RN 的一些原生依赖模块加进去,比如：</p>
<pre><code class="hljs">target <span class="hljs-string">'项目名字'</span> <span class="hljs-keyword">do</span>
    pod <span class="hljs-string">'React'</span>, <span class="hljs-symbol">:path</span> =&gt; <span class="hljs-string">'../node_modules/react-native'</span>, <span class="hljs-symbol">:subspecs</span> =&gt; [
        <span class="hljs-string">'Core'</span>,
        <span class="hljs-string">'RCTText'</span>,
        <span class="hljs-string">'RCTImage'</span>,
        <span class="hljs-string">'RCTNetwork'</span>,
        <span class="hljs-string">'RCTWebSocket'</span>, <span class="hljs-comment"># needed for localhost testing of your app</span>
        <span class="hljs-comment"># Add any other subspecs you want to use in your project</span>
    ]
<span class="hljs-keyword">end</span>
</code></pre>
<p>然后在 ios 目录下面 <code>pod install</code> 安装这些依赖，现在你应该把 RN 集成到你的 原生项目里了，但是并没有什么用，因为两者之间还没什么通信，我们还需要从原生页面进入 RN 页面，从 RN 页面回到原生页面，这里有个问题，就是如果你的 RN 页面只是一级的话那么可以直接调用原生的导航了，但是如果你的 RN 页面里面还有其他的 RN 子页面，那么我建议是在 RN 页面之间的跳转用 RN 的导航（Navigator），在 RN 页面返回到原生页面的时候调用一个原生提供的跳转方法。</p>
<p>假如你的 RN index.ios.js 文件如下所示：</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> {
  AppRegistry,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>
<span class="hljs-regexp">//</span> 把 rn 相关的代码放在 reactnative 目录下面
<span class="hljs-keyword">import</span> Navigation <span class="hljs-keyword">from</span> <span class="hljs-string">'./reactnative/components/Navigation'</span>
<span class="hljs-keyword">import</span> configureStore <span class="hljs-keyword">from</span> <span class="hljs-string">'./reactnative/store/configureStore'</span>
const store = configureStore()
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RnEntry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  render() {
   
    <span class="hljs-keyword">return</span> (
      &lt;Provider store={store}&gt;
        &lt;Navigation /&gt;
      &lt;/Provider&gt;
    )
  }
}

<span class="hljs-regexp">//</span> AppRegistry.registerComponent(<span class="hljs-string">'SimpleView'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> SimpleView)
AppRegistry.registerComponent(<span class="hljs-string">'RnEntry'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> RnEntry)
</code></pre>
<p>如果你只注册了一个 RN 入口 RnEntry （如果你想在原生里面添加不同的 RN 入口可以注册不同的组件模块），那么你在原生代码设置 RN 入口的地方可以这么写：</p>
<pre><code class="hljs"><span class="hljs-meta">#import <span class="hljs-meta-string">"RNViewController.h"</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RCTRootView.h"</span></span>
....
- (<span class="hljs-keyword">void</span>)goRN {
<span class="hljs-comment">// WithDrawEntry 就是 RN 页面注册的模块名</span>
<span class="hljs-comment">// 原生页面传给 RN 页面的参数 initialProperties，在 RN 页面通过 this.props.userId 来获取 </span>
    <span class="hljs-built_in">NSURL</span> *jsCodeLocation = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@"http://localhost:8081/index.ios.bundle?platform=ios"</span>];
    RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                        moduleName: <span class="hljs-string">@"WithDrawEntry"</span>
                                                 initialProperties: @{
                                                                        <span class="hljs-string">@"userId"</span>: TheUserService.userInfo.userId,
                                                                      <span class="hljs-string">@"userCode"</span>: TheUserService.userInfo.userCode,
                                                                      <span class="hljs-string">@"token"</span>: TheUserService.userInfo.token,
                                                                      }
                                                     launchOptions:<span class="hljs-literal">nil</span>
                             ];
    
    RNViewController *withDrawViewVC = [[RNViewController alloc] init];
    [<span class="hljs-keyword">self</span>.navigationController setNavigationBarHidden:<span class="hljs-literal">YES</span>];
    withDrawViewVC.view = rootView;
<span class="hljs-comment">// 隐藏原生的顶部导航，在 RN 里面用 RN 提供的导航</span>
    [<span class="hljs-keyword">self</span>.navigationController pushViewController:withDrawViewVC animated:<span class="hljs-literal">YES</span>];
}

<span class="hljs-keyword">@end</span>
</code></pre>
<p>然后为了方便管理代码，我们新建一个 RNModule 的目录放提供给 RN 的模块，在  RNModule 下面我们新建几个文类
1.RNViewController.m</p>
<pre><code class="hljs">
<span class="hljs-meta">#import <span class="hljs-meta-string">"RNViewController.h"</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RCTLog.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RNViewController</span> ()</span>

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RNViewController</span></span>

- (<span class="hljs-keyword">instancetype</span>)init {
  <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) {
    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(popRN) name:<span class="hljs-string">@"popRN"</span> object:<span class="hljs-literal">nil</span>];
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">void</span>)viewDidLoad {
  [<span class="hljs-keyword">super</span> viewDidLoad];
    <span class="hljs-comment">// Do any additional setup after loading the view.</span>
}

- (<span class="hljs-keyword">void</span>)popRN {
<span class="hljs-comment">// 提供一个从 RN 页面返回原生页面的方法</span>
  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
      [<span class="hljs-keyword">self</span>.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];
      [<span class="hljs-keyword">self</span>.navigationController setNavigationBarHidden:<span class="hljs-literal">NO</span>];
  });
}


<span class="hljs-keyword">@end</span>
</code></pre>
<p>2.RNViewController.h</p>
<pre><code class="hljs">
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RCTRootView.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RNViewController</span> : <span class="hljs-title">UIViewController</span></span>

<span class="hljs-keyword">@end</span>

</code></pre>
<p>3.RNNotificationManager.h //管理 原生 RN 之间的通信</p>
<pre><code class="hljs">
#<span class="hljs-keyword">import</span> &lt;Foundation/Foundation.h&gt;
#<span class="hljs-keyword">import</span> <span class="hljs-string">"RCTBridgeModule.h"</span>

@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">RNNotificationManager</span> : <span class="hljs-symbol">NSObject</span>&lt;<span class="hljs-symbol">RCTBridgeModule</span>&gt;

@<span class="hljs-symbol">end</span>
</code></pre>
<p>4.RNNotificationManager.m</p>
<pre><code class="hljs">
<span class="hljs-meta">#import <span class="hljs-meta-string">"RNNotificationManager.h"</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"RCTLog.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RNNotificationManager</span></span>

RCT_EXPORT_MODULE();


RCT_EXPORT_METHOD(postNotification:(<span class="hljs-built_in">NSString</span> *)name userInfo:(<span class="hljs-built_in">NSDictionary</span> *)userInfo)
{
  RCTLogInfo(<span class="hljs-string">@"postNotification name: %@ userInfo %@"</span>, name, userInfo);
  [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:name object:<span class="hljs-keyword">self</span> userInfo:userInfo];
}

<span class="hljs-keyword">@end</span>

</code></pre>
<p>到这里原生的代码就写的差不多了，接下来就是在 RN 的 js 代码里面引用了，假如你从原生进入 RN 的第一个页面为 Home.js：</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> React, { PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> {
  StyleSheet,
  Text,
  Platform,
  View,
  TouchableOpacity,
  NativeModules,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props) 
  }
    ...
    goToNativeView() {
    Platform.OS === <span class="hljs-string">'ios'</span> ? NativeModules.RNNotificationManager.postNotification(<span class="hljs-string">'popRN'</span>, {}) : <span class="hljs-literal">null</span> <span class="hljs-comment">// 安卓的暂时不演示</span>
  }
  render() {
   ...
   return (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TouchableOpacity</span>
       <span class="hljs-attr">onPress</span>=<span class="hljs-string">{this.goToNativeView}</span>
    &gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>回到原生页面<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">TouchableOpacity</span>&gt;</span></span>
   )
  }
}
...
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/09/17/ios-dev-2">写给前端的 iOS 开发教程(2)：熟悉 CocoaPods</a></h1><p class="post-meta">September 17, 2016</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>CocoaPods 我的理解就是和 Node 的 npm 作用差不多，用来管理一些配置依赖文件，不过它是从 Ruby 的 RubyGems,Bundler 受启发来的。如果你要用 OC 开发，肯定要学会使用 pod 的，就像你用 Node，肯定要用 npm 一样的。</p>
<p>网上也有很多 pod 的使用教程，这里也把之前的笔记简单记录一下</p>
<h2><a class="anchor" aria-hidden="true" id="使用cocoapods"></a><a href="#使用cocoapods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用CocoaPods</h2>
<p>制作和使用CocoaPods库都十分简单，往往几分钟就能配置完毕。</p>
<p>想获取最新的官方教程，<a href="http://guides.cocoapods.org/">请前往此处</a>。</p>
<h4><a class="anchor" aria-hidden="true" id="安装cocoapods"></a><a href="#安装cocoapods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装CocoaPods</h4>
<p>CocoaPods可以方便地通过RubyGems安装，打开Terminal，然后键入以下命令：</p>
<pre><code class="hljs">$ sudo gem <span class="hljs-keyword">install</span> cocoapods
</code></pre>
<p>就这么简单，现在你应该可以开始使用pod命令了。</p>
<blockquote>
<p>如果你使用Ruby版本管理器，如rbenv，你可能需要运行以下指令来重新链接shim的二进制文件（例如：$ rbenv rehash）。</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="管理相关性"></a><a href="#管理相关性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>管理相关性</h4>
<p>一个相关性管理器可以将一系列的软件需求转化为具体的标签，然后下载并且整合进入相关的项目。</p>
<p>申明需求可以自动化整个项目配置，这也是软件开发的最佳实践之一，无论是在任何语言中。甚至你不使用第三方库，CocoaPods仍然是一个管理代码相关性的绝佳工具。</p>
<h4><a class="anchor" aria-hidden="true" id="podfile"></a><a href="#podfile" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Podfile</h4>
<p>Podfile这个文件是用来用来申明项目代码相关性的，正如Bundler的Gemfile，或者npm的package.json</p>
<p>cd进入.xcodeproj文件所在的目录，通过以下命令来创建一个Podfile</p>
<pre><code class="hljs"><span class="hljs-variable">$ </span>pod init
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="podfile-1"></a><a href="#podfile-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Podfile</h4>
<pre><code class="hljs">platform <span class="hljs-symbol">:ios</span>, <span class="hljs-string">'7.0'</span>

target <span class="hljs-string">"AppName"</span> <span class="hljs-keyword">do</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>你可以申明需要不同版本的库，大部分情况下，申明到minor或者patch版本就足够了</p>
<pre><code class="hljs"><span class="hljs-attribute">pod</span> <span class="hljs-string">'X'</span>, <span class="hljs-string">'~&gt; 1.1'</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="cocoapods遵循语意化版本规范"></a><a href="#cocoapods遵循语意化版本规范" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CocoaPods遵循语意化版本规范。</h4>
<p>对于那些不在CocoaPods公共Git仓库中的库，你可以用任何一个Git, Mercurial或者SVN仓库取代，并且还可以指定具体的commit, branch或者tag。</p>
<pre><code class="hljs">pod <span class="hljs-string">'Y'</span>, :<span class="hljs-function"><span class="hljs-params">git</span> =&gt;</span> <span class="hljs-string">'https://github.com/NSHipster/Y.git'</span>, :<span class="hljs-function"><span class="hljs-params">commit</span> =&gt;</span> <span class="hljs-string">'b4dc0ffee'</span>
</code></pre>
<p>一旦所有的相关性都申明完毕，你可以使用以下指令来安装所需要的库：</p>
<pre><code class="hljs">$ pod <span class="hljs-keyword">install</span>
</code></pre>
<p>安装过程中，CocoPods会使用递归来分析所有的需求，并且建立一个代码相关性的图，最后将Podfile序列化为Podfile.lock</p>
<p>比如，如果两个库都需要使用AFNetworking，CocoaPods会确定一个同时能被这两库使用的版本，然后将同一个安装版本链接到两个不同的库中。</p>
<p>CocoaPods会创建一个新的包含之前安装好的静态库Xcode项目，然后将它们链接成一个新的libPods.a target。你原有的项目将会依赖这个新的静态库。一个xcworkspace文件会被创建，从此之后，你应该只打开这个xcworkspace文件来进行开发。</p>
<p>反复使用pod install命令，只会让CocoaPods重复以上步骤，重新安装这些库。所以，当你需要升级它们时，请使用以下命令：</p>
<p>Bash
$ pod update
试着使用CocoaPod</p>
<p>try是一个及其实用但又鲜为人知的CocoaPods命令，通过它你能够在安装一个库之前，先试用一下。</p>
<p>你只需要在try后面加上任意一个CocoaPods公共库的名称，就能试用它了！</p>
<p>Bash
$ pod try Ono
建立自己的CocoaPod</p>
<p>作为Objective-C软件分发实际上的标准，CocoaPods几乎是所有开源项目的标配，如果你想让你的项目被大家很方便地使用。</p>
<p>诚然，这会提高一点点你分享项目的门槛，但是，好处是显然易见的。你花几分钟创建一个.podspec文件可以节省下其他开发者无数的时间。</p>
<p>规范</p>
<p>.podspec文件作为CocoaPods的一个独立单元，包含了名称，版本，许可证，和源码文件等所有信息。</p>
<p>官方指南中有许多信息和范例</p>
<p>以下是NSHipsterKit.podspec</p>
<pre><code class="hljs">Pod::Spec.new <span class="hljs-keyword">do</span> <span class="hljs-params">|s|</span>
  s.name     = <span class="hljs-string">'NSHipsterKit'</span>
  s.version  = <span class="hljs-string">'1.0.0'</span>
  s.license  = <span class="hljs-string">'MIT'</span>
  s.summary  = <span class="hljs-string">"A pretty obscure library.
                You've probably never heard of it."</span>
  s.homepage = <span class="hljs-string">'http://nshipster.com'</span>
  s.authors  = { <span class="hljs-string">'Mattt Thompson'</span> =&gt;
                 <span class="hljs-string">'mattt@nshipster.com'</span> }
  s.social_media_url = <span class="hljs-string">"https://twitter.com/mattt"</span>
  s.source   = { <span class="hljs-symbol">:git</span> =&gt; <span class="hljs-string">'https://github.com/nshipster/NSHipsterKit.git'</span>, <span class="hljs-symbol">:tag</span> =&gt; <span class="hljs-string">'1.0.0'</span> }
  s.source_files = <span class="hljs-string">'NSHipsterKit'</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>一旦把这个.podspec发布到公共数据库中，任何想使用它的开发者，只需要在Podfile中加入如下声明即可：</p>
<h4><a class="anchor" aria-hidden="true" id="podfile-2"></a><a href="#podfile-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Podfile</h4>
<pre><code class="hljs"><span class="hljs-attribute">pod</span> <span class="hljs-string">'NSHipsterKit'</span>, <span class="hljs-string">'~&gt; 1.0'</span>
.podspec文件也可以作为管理内部代码的利器：
</code></pre>
<pre><code class="hljs">pod <span class="hljs-string">'Z'</span>, :<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> <span class="hljs-string">'path/to/directory/with/podspec'</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="发布cocoapod"></a><a href="#发布cocoapod" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发布CocoaPod</h4>
<p>CocoaPods 0.33中加入了Trunk服务。</p>
<p>虽然一开始使用GitHub Pull Requests来整理所有公共pods效果很好。但是，随着Pod数量的增加，这个工作对于spec维护人员Keith Smiley来说变得十分繁杂。甚至一些没有通过$ pod lint的spec也被提交上来，造成repo无法build。</p>
<p>CocoaPods Trunk服务的引入，解决了很多类似的问题。CocoaPods作为一个集中式的服务，使得分析和统计平台数据变得十分方便。</p>
<p>要想使用Trunk服务，首先你需要注册自己的电脑。这很简单，只要你指明你的邮箱地址（spec文件中的）和名称即可。</p>
<pre><code class="hljs"><span class="hljs-variable">$ </span>pod trunk register mattt<span class="hljs-variable">@nshipster</span>.com <span class="hljs-string">"Mattt Thompson"</span>
</code></pre>
<p>至此，你就可以通过以下命令来方便地发布和升级你的Pod！</p>
<pre><code class="hljs">$ pod trunk push <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NAME</span>.</span></span>podspec
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/09/17/ios-dev-1">写给前端的 iOS 开发教程(1)：Objective-C 入门</a></h1><p class="post-meta">September 17, 2016</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>之前的一个入门学习笔记，高手略过</p>
<p>PS：后面打算把之前记录在印象笔记里面的比较慢慢整理到博客上面</p>
<h2><a class="anchor" aria-hidden="true" id="不仅是学习一门新语言"></a><a href="#不仅是学习一门新语言" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不仅是学习一门新语言</h2>
<p>有过脚本开发经验的人（如Javascript，PHP，Shell）在刚开始学习iOS开发的时候，会觉得iOS开发的学习曲线比脚本语言要高，是的，这种感觉是对的。因为学iOS开发，不仅是学习一门新语言，它包括：</p>
<ul>
<li>一门语言：Objective-C</li>
<li>一个框架：Cocoa Touch</li>
<li>一个IDE：Xcode</li>
</ul>
<p>初学脚本语言通常不会来绘制图形界面、与人交互，iOS如果不做图形界面，像脚本语言一样处理文本操作数据库，就没啥意思了。</p>
<h2><a class="anchor" aria-hidden="true" id="环境准备"></a><a href="#环境准备" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>环境准备</h2>
<p>做iOS开发一定要有苹果的软件环境：Mac OS操作系统、Objective-C编译器、设备模拟器等，开发工具倒不一定要用Xcode，只要是个源代码编辑工具就行（vim都行，只是没Xcode那么多功能）。</p>
<h3><a class="anchor" aria-hidden="true" id="mac-os"></a><a href="#mac-os" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mac OS</h3>
<p>拥有Mac OS环境最简单的方法是找一台苹果电脑，包括iMac, MacBook Pro, MacBook Air, Mac Mini，但不包括苹果的移动设备（iPod Touch, iPhone, iPad, iPad Mini，它们运行的是iOS系统，不是Mac OS），苹果电脑在出厂的时候就会预装Mac OS。</p>
<p>如果囊中羞涩，可以借一台，或者上淘宝买个二手的。</p>
<h3><a class="anchor" aria-hidden="true" id="xcode-和-模拟器"></a><a href="#xcode-和-模拟器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Xcode 和 模拟器</h3>
<p>在 appstore 里面安装 xcode，挺大的估计要安装一会，最好是安装官方的，第三方提供的安装包小心安全风险</p>
<h2><a class="anchor" aria-hidden="true" id="objective-c"></a><a href="#objective-c" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Objective-C</h2>
<p>Objective-C是苹果应用软件（包括苹果电脑上的Mac OS App和移动设备上的iOS App）的开发语言。它是一种面向对象的编程语言。</p>
<p>苹果公司还提供了一个软件，叫Interface Builder，简称IB，用于可视化的界面制作，就像用Dreamweaver做网页，或者像Visual Basic做桌面软件一样。后来IB就整合进了Xcode，成了Xcode的一部分。这篇文档不讲IB，只讲Objective-C，因为：</p>
<ul>
<li>基本上，每一本讲iOS开发的书（纸质书、电子书），都有大量的截图一步一步教如何用IB开发iOS应用，而讲Objective-C开发应用的书却没有那么多。</li>
<li>IB可以用来直观方便地画界面、设置控件属性、建立代码与控件的联系，但后台的业务逻辑和数据处理仍然要靠Objective-C，可见，不管用不用IB，Objective-C都是绕不过去的。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="c的超集"></a><a href="#c的超集" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>C的超集</h3>
<p>Objective-C扩展了ANSI C，是C的超集，也就是说：</p>
<ul>
<li>任何C源程序，不经修改，即可通过Objective-C编译器成功编译</li>
<li>Objective-C源程序中可以直接使用任何C语言代码</li>
</ul>
<p>除了面向对象有语法是SmallTalk风格的（下面会讲到），其它非面向对象的语法、数据类型，与C完全相同，所以本文就不再赘述。
来看一个经典的Hello World示例吧：</p>
<pre><code class="hljs">#import &lt;Foundation/Foundation.h&gt;
int main(int argc, char *argv[]){
    @autoreleasepool{
        NSLog(@&quot;Hello World!&quot;);
    }
    return 0;
}
</code></pre>
<p>是不是仿佛穿越回了大一学习C语言的时代，看起来和C几乎没有区别，是吧？是的，因为还没用到它的面向对象特性，哈哈！</p>
<h3><a class="anchor" aria-hidden="true" id="smalltalk的消息传递语法风格"></a><a href="#smalltalk的消息传递语法风格" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SmallTalk的消息传递语法风格</h3>
<p>Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格。在源码风格方面，这是它与C Family语言（包括C/C++、Java、PHP）差别最大的地方。</p>
<p>在Java、C++世界，我们调用一个对象的某方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同的。</p>
<p>在Java里，对象和方法关系非常严格，一个方法必须属于一个类/对象，否则编译是要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态决定，给类型发送一个它无法处理的消息，也只会抛出一个异常，而不会挂掉。</p>
<pre><code class="hljs">[obj undefinedMethod];
</code></pre>
<p>在代码里调用没定义的方法（这是Java世界的习惯说法啊，专业的叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但编译能成功，运行的时候会出错。它会输出这样一个错误：</p>
<pre><code class="hljs">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[NSObject undefinedMethod]: unrecognized selector sent to instance 0x8871710'
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="类似java的oop概念"></a><a href="#类似java的oop概念" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类似Java的OOP概念</h3>
<p>Objective-C中一些面向对象的概念，也可以在Java中找到类似的实现（只能说是类似，不是完全相同），我的读者基本都是Java和PHP程序员，我会在下文中尽量用Java的概念来类比。</p>
<p>GoogleCode上有人整理了Java和Objective-C的概念、数据类型对应表，<a href="http://code.google.com/p/j2objc/wiki/JavaConversions">参见这里</a></p>
<h3><a class="anchor" aria-hidden="true" id="字符串"></a><a href="#字符串" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字符串</h3>
<p>Objective-C里有字符串是由双引号包裹，并在引号前加一个@符号，例如：</p>
<pre><code class="hljs">title = @&quot;Hello&quot;;
if(title == @&quot;hello&quot;) {}
</code></pre>
<p>PHP程序员要注意，在这里不能用单引号，即使只有一个字符也不能用。Objective-C与Java、C一样，双引号表示字符串。</p>
<h3><a class="anchor" aria-hidden="true" id="函数调用"></a><a href="#函数调用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数调用</h3>
<p>前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例：</p>
<h4><a class="anchor" aria-hidden="true" id="不带参数"></a><a href="#不带参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不带参数</h4>
<pre><code class="hljs">startedBlock();
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="带参数"></a><a href="#带参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>带参数</h4>
<pre><code class="hljs">NSLog(@&quot;decrypted string: %@&quot;, str);
CGRectMake(0,0,0,0);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="传递消息给类-实例方法"></a><a href="#传递消息给类-实例方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传递消息给类/实例方法</h3>
<h4><a class="anchor" aria-hidden="true" id="不带参数-1"></a><a href="#不带参数-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>不带参数</h4>
<pre><code class="hljs">[obj method];
</code></pre>
<p>对应的Java版本</p>
<pre><code class="hljs">obj.method();
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="带一个参数"></a><a href="#带一个参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>带一个参数：</h4>
<pre><code class="hljs">[counter increase:1];
</code></pre>
<p>对应的Java版本</p>
<pre><code class="hljs">counter.increase(1);
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="带多个参数"></a><a href="#带多个参数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>带多个参数</h4>
<p>对C Family程序员来说，这是最难接受的，最反人类的：</p>
<pre><code class="hljs">- (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue {...} //定义方法
[myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; //调用方法
</code></pre>
<p>对应的Java版</p>
<pre><code class="hljs">public void setColorToRedGreenBlue(float red, float green, float blue) {...}
myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2);
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="消息嵌套"></a><a href="#消息嵌套" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>消息嵌套</h4>
<pre><code class="hljs">UINavigationBar *bar = [[[UINavigationBar alloc] init] autorelease];
</code></pre>
<p>对应的Java版</p>
<pre><code class="hljs">UINavigationBar bar = UINavigationBar.alloc().init().autorelease();//Java没有指针，所以星号去掉了
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="类"></a><a href="#类" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类</h3>
<h4><a class="anchor" aria-hidden="true" id="接口和实现"></a><a href="#接口和实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>接口和实现</h4>
<p>Objective-C的类分为接口定义和实现两个部分。接口定义（Interface）放在头文件中，文件扩展名是.h，实现（implementation）放在实现文件中，文件扩展名是.m（也有.mm的扩展名，表示Objective-C和C++混编的代码）。</p>
<p><code>接口定义也可以写在.m文件中，但最好不要这么干</code></p>
<p>需要注意的是，与Objective-C的interface概念最接近的是C和C++里的头文件，它与implementation是成双成对出现的，作用是声明类的成员变量和方法。它与Java的interface概念完全不同：</p>
<ul>
<li>Objective-C里，interface有且只有一个实现，Java的interface可以有0-N个实现</li>
<li>Objective-C里，interface可以定义成员属性，Java里不可以</li>
</ul>
<p>在Objective-C里，和Java的Interface概念相似的是Protocol，下文会讲到。</p>
<p>请看示例：</p>
<p>Interface</p>
<pre><code class="hljs">@interface MyClass {
    int memberVar1;
    id  memberVar2;
}

-(return_type) instance_method1; 
-(return_type) instance_method2: (int) p1;
-(return_type) instance_method3: (int) p1 andPar: (int) p2;
@end
</code></pre>
<p>Implementation</p>
<pre><code class="hljs">@implementation MyClass {
    int memberVar3;
}

-(return_type) instance_method1 {
    ....
}
-(return_type) instance_method2: (int) p1 {
    ....
}
-(return_type) instance_method3: (int) p1 andPar: (int) p2 {
    ....
}
@end
</code></pre>
<p>接口和实现以@interface、@implementation开头，都以@end结束。“@”符号在Objective-C中是个很神奇的符号。</p>
<p>冒号也是方法名的一部分，method和method:是两个不同的方法名，不是overload，第二个带参数。</p>
<p>上述代码对应的Java版：</p>
<pre><code class="hljs">public class MyClass {
    protected int memberVar1;
    protected pointer memberVar2;
    private int memberVar3;
    
    public (return_type) instance_method1() {
        ....
    }
    
    public (return_type) instance_method2(int p1) {
        ....
    }
    
    public (return_type) instance_method3andPar(int p1, int p2) {
        ....
    }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="私有方法和公开方法"></a><a href="#私有方法和公开方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>私有方法和公开方法</h4>
<p>写在.h头文件里的方法都是公开的，Objective-C里没有私有方法的概念（没有你说个蛋啊，哈哈哈哈）。</p>
<p>官方并没有提到Objective-C怎么实现私有方法，我查阅了stackoverflow，统一的答案是，要实现私有方法的效果只能借助Category，不过，根据我的测试，即使采用了Category，也不能阻止外部的代码调用这个“私有方法”，只是Xcode不支持“私有方法”的自动完成，并会有警告提示，运行的时候，还是会成功的。各位看官知道有这么回事就可以了，这里不深讲。</p>
<h4><a class="anchor" aria-hidden="true" id="变量和属性"></a><a href="#变量和属性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>变量和属性</h4>
<h4><a class="anchor" aria-hidden="true" id="类方法和实例方法"></a><a href="#类方法和实例方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类方法和实例方法</h4>
<h5><a class="anchor" aria-hidden="true" id="类方法"></a><a href="#类方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类方法</h5>
<p>类方法就是Java、PHP里的Static Method，不用实例化就能调。类方法有一个加号前缀。
示例：</p>
<p>类定义</p>
<pre><code class="hljs">@interface MyClass
    +(void) sayHello;
@end

@implementation MyClass

+(void) sayHello {
    NSLog(@&quot;Hello, World&quot;);
}
@end
</code></pre>
<p>使用</p>
<pre><code class="hljs">[MyClass sayHello];
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="实例方法"></a><a href="#实例方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实例方法</h5>
<p>实例方法就是Java、PHP里的普通方法，必须实例化才能调。实例方法有一个减号前缀。
示例：</p>
<p>类定义</p>
<pre><code class="hljs">@interface MyClass : NSObject
-(void) sayHello;
@end

@implementation MyClass

-(void) sayHello {
    NSLog(@&quot;Hello, World&quot;);
}
@end
</code></pre>
<p>使用</p>
<pre><code class="hljs">mycls = [MyClass new];
[mycls sayHello];
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="selector"></a><a href="#selector" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Selector</h4>
<p>selector就是一个方法指针，类似PHP里的动态方法名：</p>
<pre><code class="hljs">&lt;?php
class Hello {
    public function sayHello() {}
    
    public function test() {
        $fun_name = &quot;sayHello&quot;;
        $this-&gt;$fun_name();
    }
}
</code></pre>
<p>在Objective-C里，selector主要用来做两类事情：</p>
<h5><a class="anchor" aria-hidden="true" id="绑定控件触发的动作"></a><a href="#绑定控件触发的动作" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>绑定控件触发的动作</h5>
<pre><code class="hljs">@implementation DemoViewController
- (void)downButtonPressed:(id)sender {//响应“按钮被按下事件”的方法
    UIButton *button = (UIButton*)sender;
    [button setSelected:YES];
}

- (void)drawAnButton {
    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; 
    btn.frame = _frame; 
    btn.tag = 1;
    btn.backgroundColor = [UIColor clearColor];
    [btn addTarget: self
         action: @selector(downButtonPressed:)
         forControlEvents: UIControlEventTouchUpInside];//当这个按钮被按下时，触发downButtonPressed:方法
}
@end
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="延时异步执行"></a><a href="#延时异步执行" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延时异步执行</h5>
<pre><code class="hljs">@implementation ETHotDealViewController
- (void)viewDidLoad {
    
    //获取数据源
    HotDealDataSource *ds = [[HotDealDataSource alloc]init];
    [ds reload];
    _items = ds.items;
    
    [self performSelector: @selector(refreshTable)
          withObject: self
          afterDelay: 0.5];//延迟0.5秒调用refreshTable方法
}

-(void)refreshTable
{
    [self.tableView reloadData];
}
@end
</code></pre>
<p>这个例子中，获取数据源是通过ASIHTTP组件异步调用服务端HTTP接口，refreshTable要用到数据源返回回来的数据，如果不延迟0.5秒，就会立刻执行，执行的时候数据还在路上呢，页面就要变空白了。</p>
<h3><a class="anchor" aria-hidden="true" id="继承"></a><a href="#继承" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>继承</h3>
<p>继承是写在Interface定义里面的。语法为：子类名在左，父类名在右，中间用冒号分隔。
示例：</p>
<pre><code class="hljs">@interface MyClass : NSObject
@end
</code></pre>
<p>对应的Java版本是：</p>
<pre><code class="hljs">public class MyClass extends NSObject {
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="协议-protocol"></a><a href="#协议-protocol" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协议（Protocol）</h3>
<p>就是Java、PHP里的Interface。</p>
<h4><a class="anchor" aria-hidden="true" id="协议的定义"></a><a href="#协议的定义" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协议的定义</h4>
<p>协议的定义用@protocol关键字：</p>
<pre><code class="hljs">@protocol Printable
    -(void)print:(NSString)str;
@end
</code></pre>
<p>对应的Java版本是：</p>
<pre><code class="hljs">publilc interface Printable {
    public void print(String str);
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="协议的继承"></a><a href="#协议的继承" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协议的继承</h5>
<p>协议本身也可以继承别的协议：</p>
<pre><code class="hljs">@protocol Printable &lt;NSObject&gt;
    -(void)print:(NSString)str;
@end
</code></pre>
<p>对应的Java版本：</p>
<pre><code class="hljs">public interface Printable extends NSObject {
    public void print (String str);
}
</code></pre>
<h5><a class="anchor" aria-hidden="true" id="可选方法"></a><a href="#可选方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>可选方法</h5>
<p>协议可以包含可选方法，顾名思义，可选方法可以不被类实现：</p>
<pre><code class="hljs">@protocol Printable
@optional
    -(void)print:(NSString)str;
@end
</code></pre>
<p>加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。</p>
<p>Java里没有类似的实现，除了Collection里会有一些方法带有optional的注释，但Collection是个特例。</p>
<h4><a class="anchor" aria-hidden="true" id="协议的实现"></a><a href="#协议的实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协议的实现</h4>
<p>一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。</p>
<p>示例：</p>
<pre><code class="hljs">@interface  class MyClass : NSObject &lt;Printable, Drawable&gt;
@end
</code></pre>
<p>Printable, Drawablw就是两个协议。</p>
<p>对应的Java版本是：</p>
<pre><code class="hljs">public class MyClass extends NSObject implements Printable, Drawable {
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="分类-category"></a><a href="#分类-category" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分类（Category）</h3>
<p>分类可以给一个已经存在的类增加方法，而不用去改它的源码。Java和PHP中都没有类似的特性。</p>
<p>比如说，NSObject是一个Objective-C内置的系统类，我们想给它增加toJson方法，就像这样：</p>
<p>头文件：NSObject+Json.h</p>
<pre><code class="hljs">@interface NSObject (Json)
    -(NSString)toJson;
@end
</code></pre>
<p>实现文件：NSObject+Json.m</p>
<pre><code class="hljs">@implementation NSObject (Json)
    -(NSString)toJson {
        //...
    }
@end
</code></pre>
<p>使用的时候，只要包含NSObject+Json.h，实例化NSObject类，就可以使用toJson方法了：</p>
<pre><code class="hljs">import &quot;NSObject+Json.h&quot;
@implatementation XYZController
    -(void)test {
        NSObject *obj = [[NSObject alloc]init];
        NSString *str = [obj toJson];
    }
@end
</code></pre>
<p>当然了，NSObject本来的那些方法依然还是可以用的，什么都没变，只是多了个toJson方法。看起来是不是和继承没太多差别呢（除了使用的时候实例化的是NSObject，而不是JsonObject）？再看一个继承实现不了的例子：</p>
<p>头文件：NSObject+Json+XML.h</p>
<pre><code class="hljs">@interface NSObject (Json)
    -(NSString)toJson;
@end

@interface NSObject (XML)
    -(NSString)toXML;
@end
</code></pre>
<p>实现文件：NSObject+Json+XML.m</p>
<pre><code class="hljs">@implementation NSObject (Json)
    -(NSString)toJson {
        //...
    }
@end

@implementation NSObject (XML)
    -(NSString)toXML {
        //...
    }
@end
</code></pre>
<p>使用：</p>
<pre><code class="hljs">import &quot;NSObject+Json+XML.h&quot;
@implatementation XYZController
    -(void)test {
        NSObject *obj = [[NSObject alloc]init];
        NSString *json = [obj toJson];
        NSString *xml = [obj toXML];
    }
@end
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="cocoa-touch"></a><a href="#cocoa-touch" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cocoa Touch</h2>
<p>Cocoa是Mac OS App的开发框架，Cocoa Touch是iOS开发用的框架，Cocoa Touch和Cocoa大部分是一样的，只是Cocoa Touch多了一些移动设备特有的东西，如：触摸屏、加速度传感器、GPS定位。Cocoa中多任务、多窗口的特性，在Cocoa Touch中也是没有的（或者跟Cocoa不完全一样的）。</p>
<p>就像学了Java语言还要再学一些Spring、Hibernate、Struts（或者其它类似的Java类库）才能开始做J2EE应用一样，学过Objective-C语言之后，也要再学习Cocoa Touch框架才能顺利地开发iOS应用。</p>
<h3><a class="anchor" aria-hidden="true" id="最常用设计模式之delegate"></a><a href="#最常用设计模式之delegate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最常用设计模式之Delegate</h3>
<p>Cocoa Touch大量使用Delegate（委派）设计模式。</p>
<h3><a class="anchor" aria-hidden="true" id="常用控件-按钮-文本块-图片-输入框"></a><a href="#常用控件-按钮-文本块-图片-输入框" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>常用控件：按钮、文本块、图片、输入框</h3>
<h3><a class="anchor" aria-hidden="true" id="tableview"></a><a href="#tableview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TableView</h3>
<h3><a class="anchor" aria-hidden="true" id="webview"></a><a href="#webview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WebView</h3>
<h3><a class="anchor" aria-hidden="true" id="导航条"></a><a href="#导航条" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>导航条</h3>
<h2><a class="anchor" aria-hidden="true" id="xcode"></a><a href="#xcode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Xcode</h2>
<h3><a class="anchor" aria-hidden="true" id="运行"></a><a href="#运行" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>运行</h3>
<p>快捷键：Comman R</p>
<h3><a class="anchor" aria-hidden="true" id="搜索"></a><a href="#搜索" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>搜索</h3>
<h4><a class="anchor" aria-hidden="true" id="搜索文本"></a><a href="#搜索文本" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>搜索文本</h4>
<h4><a class="anchor" aria-hidden="true" id="搜索文件"></a><a href="#搜索文件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>搜索文件</h4>
<h3><a class="anchor" aria-hidden="true" id="新建文件-目录"></a><a href="#新建文件-目录" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新建文件/目录</h3>
<p>推荐在Finder中新建好的再添加进来</p>
<h3><a class="anchor" aria-hidden="true" id="断点"></a><a href="#断点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>断点</h3>
<h2><a class="anchor" aria-hidden="true" id="模拟器和真机测试"></a><a href="#模拟器和真机测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模拟器和真机测试</h2>
<h3><a class="anchor" aria-hidden="true" id="模拟器测试"></a><a href="#模拟器测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模拟器测试</h3>
<p>在Xcode中打开你的项目，在Xcode顶部工具栏的Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中iPhone 5.0 Simulator（这里的5.0是指iOS版本，不是iPhone5的意思，如果你的项目是iPad应用，请选iPad 5.0 Simulator），再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到模拟器上。</p>
<p>在模拟器上操作时，如果执行过程中遇到了你在Xcode里设置的断点，模拟器会暂停运行，并将当前活动窗口切换回Xcode，供你调试。</p>
<p>在Xcode里增加或者取消了断点，不需要重新编译和安装应用即可生效。</p>
<h4><a class="anchor" aria-hidden="true" id="切换被模拟的设备"></a><a href="#切换被模拟的设备" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>切换被模拟的设备</h4>
<p>模拟器的“硬件”菜单，可以选择想要模拟什么设备，有iPad、iPhone可选。</p>
<ul>
<li>Retina：表示视网膜屏，iPhone(Retina)代表iPhone4，iPhone4S</li>
<li>4-Inch：表示4英寸的iPhone，iPhone(Retina 4-Inch)就是iPhone 5</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="切换模拟的ios版本"></a><a href="#切换模拟的ios版本" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>切换模拟的iOS版本</h4>
<p>在模拟器的“版本”菜单，可以选择要模拟什么版本的iOS。设备和版本是彼此独立的，iPhone 4S可以有5.0，5.1，6.1几种iOS版本，当然了，iPhone 5不可能有4.3的iOS版本。</p>
<h4><a class="anchor" aria-hidden="true" id="触摸屏"></a><a href="#触摸屏" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>触摸屏</h4>
<p>用鼠标点击（不区分左右键）模拟器上的iPhone、iPad屏幕，就是在模拟用手指触摸iPhone，iPad的屏幕，可以实现一些触摸效果比如：</p>
<ul>
<li>鼠标单击 等于 手指轻触</li>
<li>鼠标长按 等于 手指长按（例如你可以在模拟器上长按应用icon调出删除应用的确认框）</li>
<li>鼠标按住拖动 等于 手指拖动</li>
<li>双击和单击模拟器的Home键也等于双击和单击真机的Home键</li>
</ul>
<h5><a class="anchor" aria-hidden="true" id="多指手势"></a><a href="#多指手势" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多指手势</h5>
<p>多指手势比较复杂，在白苹果笔记本上可以模拟简单的双指手势，白苹果的触控板天然支持多指触摸，但要定位到模拟器的区域再响应多指手势就需要借助一些额外的键啦：</p>
<ul>
<li>按住Option键，再用两个手指去操作触摸板，可模拟双指拖动、旋转</li>
<li>按住Option+Shift，可模拟双指合拢</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="输入法和键盘"></a><a href="#输入法和键盘" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>输入法和键盘</h4>
<h5><a class="anchor" aria-hidden="true" id="输入中文"></a><a href="#输入中文" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>输入中文</h5>
<p>手机上特有的输入法（比如九宫格输入法）不能模拟。模拟器默认的iOS软键盘只有英文输入，在测试应用的时候，我们要用到中文，有两个办法：</p>
<ul>
<li>使用剪贴板，在Mac OS里复制，再到模拟器运行的应用中的输入框上长按鼠标（模拟手指长按）3秒以上，等弹出“粘贴”的时候选择之，即可。</li>
<li>在模拟器里，按Home键，找到Setting那个App icon（不是Mac OS顶部的模拟器菜单啊，那里没有Setting的），打开被模拟iOS设备的设置，依次点击”General - Keyboard - International Keyboards - Add New Keyboard…”，加个中文键盘，以后就可以使用被模拟iOS设备软件盘输入中文了，跟在iPhone/iPad真机上一样。</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="使用mac电脑的键盘"></a><a href="#使用mac电脑的键盘" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用Mac电脑的键盘</h4>
<p>如果要输入大量文本，使用模拟器里的软键盘效率太低，这时候可以使用物理键盘，方法是：在Mac OS顶部的模拟器菜单栏，点击”硬件”菜单，勾选下拉菜单中的“模拟硬件键盘”。以后再用模拟器运行iOS应用时，点击iOS应用中的输入框，软键盘就不弹出来了，可直接使用Mac电脑的物理键盘输入。</p>
<p><em>注意</em>：</p>
<ul>
<li>模拟器中的iOS接管了物理键盘输入，所以，调用的是模拟器iOS的输入法，不是你的Mac电脑的输入法。打个比方，你的Mac OS装的是搜狗五笔，模拟器中iOS加了个拼音输入法（Add New Keyboard），那么，在iOS应用中输入中文会调用拼音输入法。</li>
<li>要切换模拟器中iOS的中英文输入法，也只能按iOS设备软键盘上的小地球图标，按Mac电脑上的Command+空格键是不行的。</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="地理位置"></a><a href="#地理位置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>地理位置</h4>
<p>但Mac电脑没有定位用的硬件（GPS）和软件基础，因此模拟器不能自动获得当前的地理位置，不能用模拟器测试定位功能。（注意，虽然WiFi也可以独立定位——iPad WiFi版没有GPS也可以定位，但Mac电脑的WiFi不具备定位相关的软件）</p>
<p>要在模拟器里测试依赖地理位置的功能（如”我附近的xx”），可以手工指定一个经纬度给模拟器，方法：在Mac电脑顶部的模拟器菜单，点击”调试 - 位置 - 自定位置”，会弹出一个对话框，在弹出的框内填入经纬度即可。</p>
<p>如何获得经纬度？
上谷歌地图（ditu.google.cn），在地图上找到你想要的位置（比如你想知道杭州大厦的位置，就在通过搜索框找到杭州大厦），点击右键，选择“这儿是什么”，搜索框中就会出现这个位置的经纬度了，前面是纬度，后面是经度。咱们天朝的版图，都是北纬和东经。</p>
<h4><a class="anchor" aria-hidden="true" id="摄像头"></a><a href="#摄像头" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>摄像头</h4>
<p>Mac电脑有摄像头，但Mac OS没有设计API给iOS模拟器调用，所以，不能用模拟器测试对焦闪光灯等功能。</p>
<p>要在模拟器上测试依赖照片的功能，可以在代码里做一个workaround，即当代码检测到摄像头不可用时，弹出一个照片选择器，让测试人员从相册里选择一幅照片，来进行后续的操作（如照片美化、人脸识别、条码扫描）。</p>
<h3><a class="anchor" aria-hidden="true" id="真机测试"></a><a href="#真机测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>真机测试</h3>
<p>模拟器能验证你开发的iOS应用的大部分功能，但有些Mac设备上不具备的硬件，模拟器是不能模拟的。前文提到了一个绕过这些限制的办法，但获取当前位置、拍照、加速度感应这些是模拟不了的，一款应用发布给消费者之前，必须要在真实设备上验证过。</p>
<p>将未提交App Store审核通过的应用安装到iOS设备上测试，有三种办法：</p>
<ul>
<li>加入苹果的Developer Program，成为付费会员，有了这个付费会员资格，就可以直接在Xcode中点击”Run”将刚刚改过的代码编译打包安装到开发测试用的iOS设备上。在iOS真机上操作被测试的程序能激活Xcode中设置的断点。</li>
<li>越狱iOS设备。将iPhone和iPad越狱后，可以通过SSH直接上传Xcode编译好的ipa包（一个iOS App本质上就是一个ipa包）。</li>
<li>越狱的iOS设备，配合破解过的Xcode，甚至可以实现和付费开发者计划一样的功能：在Xcode上点击”Run”，就自动编译安装到iOS设备上去运行了</li>
<li>企业部署方案。就像阿里巴巴的<a href="http://xyj.im">轩辕剑</a>一样，用iPhone/iPad访问这个网址，点击里面的轩辕剑链接就可以安装轩辕剑这个应用了。</li>
</ul>
<p>破解Xcode是违法行为（越狱是合法的），而且挑版本挑得厉害，不是所有Xcode版本都能破解，也不是所有Xcode的破解版都能和越狱的iOS配合好。越狱+SSH上传跟企业部署一样效率低（部署效率低，无法激活Xcode中的断点），只能用于QA验收，不适合开发自测。综上所述，最适合开发实时测试的就是第一个正规途径了。下面重点讲这个：</p>
<h4><a class="anchor" aria-hidden="true" id="拥有一个开发者账号"></a><a href="#拥有一个开发者账号" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拥有一个开发者账号</h4>
<p>苹果的Developer Program分为个人开发者和公司开发者，分别是每年99美元和每年299美元，分别可以注册100台和500台苹果测试设备。这个台数限制在一个付费年度内不会清空，比如说，2013年4月1日付费成功的，付费会员资格在2014年3月31日之前有效，这期间，注册一台就少一个名额，哪怕这个设备注册进来用了之后一分钟马上又删掉了，减少的这个名额也不会回来。</p>
<p>在交钱之前，最好问一下，周围的同事，有没有已经交了钱的。如果有，你只需要注册一个免费的Apple ID（就是你在App Store安装软件用的Apple ID），请他发个邀请邮件给你，把你的Apple ID加入他的团队就可以了，苹果会认为你们两个人是一个团队的，你们分别用自己的账号，共享100台设备的限额，这是合法的。</p>
<h4><a class="anchor" aria-hidden="true" id="安装证书和私钥"></a><a href="#安装证书和私钥" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装证书和私钥</h4>
<h5><a class="anchor" aria-hidden="true" id="证书"></a><a href="#证书" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>证书</h5>
<p>不想看下面各种点击各种页面跳转的直接用浏览器访问<a href="https://developer.apple.com/ios/manage/certificates/team/index.action">证书管理</a>，你要登录你就用Apple ID登录（前提是交过钱，或者找交了钱的人把你加入团队了）。</p>
<blockquote>
</blockquote>
<p>不嫌烦，或者想知道下次没我这个文档的时候怎么进证书管理吗？按这个步骤操作：</p>
<ul>
<li>进入 <a href="https://developer.apple.com/">苹果开发者中心</a></li>
<li>点击iOS Dev Center</li>
<li>点蓝色“Login”按钮，用你的Apple ID登录，登录成功会跳到 <a href="https://developer.apple.com/devcenter/ios/index.action">开发者首页</a></li>
<li>点击右上角的<a href="https://developer.apple.com/ios/manage/overview/index.action">iOS Provisioning Portal</a>（别找了，直接Command F搜索多好）</li>
<li>点左侧菜单栏里的<a href="https://developer.apple.com/ios/manage/certificates/team/index.action">Certificates</a></li>
</ul>
<p>页面上有一个“Your Certificate”区域，下方有个Download圆角按钮，这是你的个人证书，下载下来。再下面一行，有一句“If you do not have the WWDR intermediate certificate installed, <a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer">click here to download now</a>”，这个是苹果的公共证书，也下下来。</p>
<p>双击下载回来的证书，装证书时，会提示你输入密码，这是【钥匙串访问工具】在问你要你的Mac OS账号开机密码（相当于linux里面的sudo），不是Apple ID的密码，不要搞错了。</p>
<h5><a class="anchor" aria-hidden="true" id="安装私钥"></a><a href="#安装私钥" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装私钥</h5>
<p>如果你是和其它同事公用的账号，让他给你一个私钥即可，就是一个扩展名为p12的文件，双击之，钥匙串访问会自动出来，需要你输入一个密码，这个密码问给你p12文件的人要，不是你的Mac OS系统开机密码，也不是你的Apple ID密码。</p>
<h4><a class="anchor" aria-hidden="true" id="将设备注册到provisioning-portal"></a><a href="#将设备注册到provisioning-portal" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将设备注册到Provisioning Portal</h4>
<ul>
<li>打开Xcode，从Xcode的Window菜单中找到Organizer，打开之（Shift Command 2）。</li>
<li>把iOS设备连上电脑，Organizer会自动识别出你的设备，并显示在左侧边栏。</li>
<li>在Organizer左侧边栏找到你的设备，右键，点击“Add Device to Provisioning Portal”，然后等Organizer提示你操作成功即可。（选中设备后，右边设备详情区域会显示一个按钮“Use for Development”，点它也可以）。</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="到ios真机上运行测试版程序"></a><a href="#到ios真机上运行测试版程序" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>到iOS真机上运行测试版程序</h4>
<p>回到Xcode主界面，在Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中你的真机设备名，再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到真机上测试啦！</p>
<h4><a class="anchor" aria-hidden="true" id="发布到app-store"></a><a href="#发布到app-store" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发布到App Store</h4>
<h4><a class="anchor" aria-hidden="true" id="打ipa包"></a><a href="#打ipa包" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>打IPA包</h4>
<p>IPA包本质上是一个ZIP压缩包，只不过它有着特殊的目录结构，扩展名是ipa，制作方法如下：</p>
<ul>
<li>在Xcode中Build项目，快捷键Command B</li>
<li>在左侧项目导航器中，展开Products文件夹，找到你要打包的应用，你的应用名.app，右键，选择show in finder</li>
<li>到Finder中Copy这个.app目录（选中，按Command C），复制到一个你新建的名为Payload（区分大小写）的文件夹中</li>
<li>找到你的应用Logo，即一个512 * 512像素的PNG文件，copy到与Payload一起（与Payload并列，不要放进Payload了），并重命名为iTunesArtwork（区分大小写，没有扩展名）</li>
<li>将Payload目录、ItunesArtwork文件打成一个zip包，并更改扩展名为ipa</li>
<li>双击这个ipa文件，会用iTunes打开，如果打开成功，且在iTunes里有应用Logo显示，就成功了</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="批量自动打包"></a><a href="#批量自动打包" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>批量自动打包</h4>
<p>除App Store外，还有许多其它的iOS应用市场（如91助手，同步推等等），如果一个应用需要发布到很多个应用市场，且他们的代码略有不同（比如说，统计代码不同），按上述方法手工修改源码再打包，再还原，比较容易出错。好消息是，Xcode是有命令行的，我们可以写一个shell脚本，先用se自动修改源码，再调用Xcode的命令行来编译以得到your——app.app目录，最后调用zip、mv等命令把上一个章节讲的ipa打包动作自动执行。</p>
<h3><a class="anchor" aria-hidden="true" id="xcode中的代码结构与操作系统上的文件系统并不一致"></a><a href="#xcode中的代码结构与操作系统上的文件系统并不一致" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Xcode中的代码结构与操作系统上的文件系统并不一致</h3>
<p>推荐在Finder里建好目录再到Xcode的Project Navigator中点击“Add Files to”添加到项目中</p>
<h3><a class="anchor" aria-hidden="true" id="objective-c教程"></a><a href="#objective-c教程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Objective-C教程</h3>
<ul>
<li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">Apple官方教程</a></li>
<li><a href="http://cocoadevcentral.com/d/learn_objectivec/">Cocoa Dev Center</a></li>
<li><a href="http://zh.wikipedia.org/wiki/Objective-C">维基上的Objective-C语言简介</a> --中文，十分钟可读完，推荐</li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/08/16/target-blank">使用 target=&quot;_blank&quot; 的一个漏洞</a></h1><p class="post-meta">August 16, 2016</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>这个问题前几个月在 HN 上有人讨论过，但是今天遇到了就再记录一下，毕竟国外有人说过这是一个最为低估的一个漏洞。</p>
<p>平常我们通过 a 标签新打开页面的时候会给 a 标签添加 target=&quot;_blank&quot; 属性，表示新开一个窗口打开。但是在新页面的 window 对象中，存在一个 opener 属性，保存对父页面的引用，而且这个在不同域之间也是存在的。</p>
<p>就意味着在父页面新窗口打开一个链接，跳到子页面后，子页面可以控制父页面的一些行为，比如让父页面重定向到一个逼真的钓鱼页面，因为此时用户的注意力在新开的窗口，很难注意到父页面发生的变化。</p>
<p>在很长的一段时间，浏览器厂商对这个 bug 并不 care( <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=168988">
Security: if window.opener exists, a page can trigger a navigation in the opener regardless of security origin -
Monorail</a> )。按照他们的意思就是你不要在新窗口打开页面，直到前几个月才对这个bug 有了一个比较好的解决方案，那就是给 a 标签添加 <code>rel=noopener</code> 属性，可以在 <a href="https://html.spec.whatwg.org/#link-type-noopener">HTML Standard</a>看到这个属性说明，在 ff 浏览器里面要再加上 <code>rel=&quot;noreferrer&quot;</code>才能生效。所以如果你要通过 a 标签新打开个页面，你的正确写法应该是：
<code>&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;&lt;/a&gt;</code></p>
<p>在一些老浏览器里面不支持这个属性，就可以通过js 手动设置  opener 为 null 来解决：</p>
<pre><code class="hljs css language-js">var newWnd = window.open('http://baidu.com);
newWnd.opener = null;
newWnd.location = url;
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/06/06/Virtual-Dom3">动手写一个简单的 Virtual Dom（3）</a></h1><p class="post-meta">June 6, 2016</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>前一篇文章介绍了 Virtual Dom 的属性设置等，现在再讲一下  Virtual Dom 怎么绑定事件。
平常我们给 DOM 绑定事件的写法可能是这样：<code>querySelector('xx').addEventListener(..)</code>
但是在 React 里面我们不这样写，我们直接在 DOM 上通过属性来绑定：</p>
<pre><code class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> alert(‘hi!’)}&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</code></pre>
<p>上面我们有一个专门监听事件的属性，并且都以 'on' 开头，下面我们写一个函数来判断该属性是不是绑定事件的：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEventProp</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^on/</span>.test(name);
}
</code></pre>
<p>下面我们还需要一个方法来从属性里面把 事件属性名给提出来：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractEventName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> name.slice(<span class="hljs-number">2</span>).toLowerCase();
}
</code></pre>
<p>现在还有个问题就是我们这个监听事件的属性其实和其他的正常属性是不一样的，所以我们需要在 isCustomProp 里面
处理这个属性：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCustomProp</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> isEventProp(name);
}
</code></pre>
<p>接下来就是真正的给 Dom 监听事件的属性添加监听函数了：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListeners</span>(<span class="hljs-params">$target, props</span>) </span>{
  <span class="hljs-built_in">Object</span>.keys(props).forEach(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (isEventProp(name)) {
      $target.addEventListener(
        extractEventName(name),
        props[name]
      );
    }
  });
}
</code></pre>
<p>然后把上面这个放到 <code>createElement</code> 里面去：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node === ‘string’) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createTextNode(node);
  }
  <span class="hljs-keyword">const</span> $el = <span class="hljs-built_in">document</span>.createElement(node.type);
  setProps($el, node.props);
  addEventListeners($el, node.props);
  node.children
    .map(createElement)
    .forEach($el.appendChild.bind($el));
  <span class="hljs-keyword">return</span> $el;
}
</code></pre>
<p>到这里监听事件的功能基本上就好了，但是还有一个小问题，就是重复添加事件的问题，虽然这个需求很少，但是还是不可避免的会有，
所以我们可以添加一个强制更新的属性 'forceUpdate'，然后修改之前的那个 change 函数：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changed</span>(<span class="hljs-params">node1, node2</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> node1 !== <span class="hljs-keyword">typeof</span> node2 ||
         <span class="hljs-keyword">typeof</span> node1 === ‘string’ &amp;&amp; node1 !== node2 ||
         node1.type !== node2.type ||
         node.props.forceUpdate;
}
</code></pre>
<p>当 'forceUpdate' 为 true 时，这个 Dom 节点会完全重新重新创建并且把事件监听加上，这里就还需要修改下之前的 isCustomProp 函数：</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCustomProp</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> isEventProp(name) || name === ‘forceUpdate’;
}
</code></pre>
<p>下面是完整的 DEMO：<a href="https://jsfiddle.net/gothic/as87qdyc/3/">https://jsfiddle.net/gothic/as87qdyc/3/</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/06/06/Virtual-Dom2">动手写一个简单的 Virtual Dom（2）</a></h1><p class="post-meta">June 6, 2016</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>上一篇文章其实就是介绍了怎么创建虚拟 DOM，真的只是创建 DOM 元素而已，因为没有设置属性的功能，事件绑定的功能也没有。
现在慢慢的一个个来实现吧。</p>
</span></div><div class="read-more"><a class="button" href="/blog/2016/06/06/Virtual-Dom2">Read More</a></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2016/06/06/Virtual-Dom1">动手写一个简单的 Virtual Dom（1）</a></h1><p class="post-meta">June 6, 2016</p><div class="authorBlock"><p class="post-authorName"><a href="http://github.com/go7hic" target="_blank" rel="noreferrer noopener">Go7hic</a></p></div></header><article class="post-content"><div><span><p>Virtual Dom 又叫虚拟 DOM，随着 React 一起火起来的一个概念。虚拟 DOM 做到极致能够极大的提升性能，据说 Vue2 的 Virtual DOM 实现性能提升了很高。不过这些我们暂时不管，我们只要知道大致原理就可以自己来试着实现一个类似的乞丐版 Virtual Dom。</p>
</span></div><div class="read-more"><a class="button" href="/blog/2016/06/06/Virtual-Dom1">Read More</a></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/blog/page2/">Next →</a></div></div></div></div></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2019 Go7hic</section></footer></div></body></html>